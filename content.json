{"meta":{"title":"Blog for ZJ Xue","subtitle":"编程 日志 杂谈","description":"我们终将在硅和铁的永恒中融为一体","author":"ZJ Xue","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于我","date":"2020-03-19T15:25:10.000Z","updated":"2021-07-22T01:19:58.373Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"About Me 关于作者|･ω･｀) 作者包括以下属性： 不起眼的大学生 直男审美 段尾偶尔不加句号 喜欢自己造名词 单身二十年 Hacker精神 源码魔改信仰 沉迷前端的后端开发 鼓吹C++的Java工程师 逆向工程 内核爱好者 完全不懂硬件 MMA运动老粉 ACG 中二病 脑内彼女玩家 黄金舰队领航员 银月城居民 前任鹏洛客 暗影守望成员 机械神教"},{"title":"标签","date":"2020-03-19T13:54:31.000Z","updated":"2021-07-22T01:19:58.467Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"archives","date":"2020-03-19T13:47:10.000Z","updated":"2021-07-22T01:19:58.373Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-03-19T13:46:36.000Z","updated":"2021-07-22T01:19:58.374Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"timeline","date":"2020-03-19T13:51:06.000Z","updated":"2021-07-22T01:19:58.468Z","comments":true,"path":"timeline/index.html","permalink":"http://yoursite.com/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"置顶-达瓦里希戳这里","slug":"readme","date":"2099-12-31T15:59:59.000Z","updated":"2021-11-30T12:10:20.814Z","comments":true,"path":"2099/12/31/readme/","link":"","permalink":"http://yoursite.com/2099/12/31/readme/","excerpt":"读文须知 欢迎来到我的博客主站，目前暂时停更，博文更新请前往bladeXue/blog 博文内容可能包括出版物的摘录，开源项目的代码片段，各类技术博文的参考等，如有侵权现象发生，请在评论区，项目issue或者邮件bb我 如果发现有错误或者笔误，同样可以通过邮件/评论/issue来bb我（本博评论系统用的Disqus，现在访问需要梯子，看不见评论区的旁友记得找个机场） 游戏玩家可以找我打山口山或者守望先锋，id提斯雷尔#5596，专业金色天使","text":"读文须知 欢迎来到我的博客主站，目前暂时停更，博文更新请前往bladeXue/blog 博文内容可能包括出版物的摘录，开源项目的代码片段，各类技术博文的参考等，如有侵权现象发生，请在评论区，项目issue或者邮件bb我 如果发现有错误或者笔误，同样可以通过邮件/评论/issue来bb我（本博评论系统用的Disqus，现在访问需要梯子，看不见评论区的旁友记得找个机场） 游戏玩家可以找我打山口山或者守望先锋，id提斯雷尔#5596，专业金色天使","categories":[],"tags":[]},{"title":"x86汇编指南-导读","slug":"asm/x86-assembly-guide","date":"2020-11-23T17:07:55.000Z","updated":"2021-07-22T01:19:58.368Z","comments":true,"path":"2020/11/24/asm/x86-assembly-guide/","link":"","permalink":"http://yoursite.com/2020/11/24/asm/x86-assembly-guide/","excerpt":"x86汇编指南-导读 关于本篇 本文是我写的一系列关于x86架构下，CPU的保护模式和汇编原理相关的博客的导读，这些博客相互独立，但是为了方便阅读和索引，我在这里做了个目录。这些博客没有过度深究汇编器实现的具体细节，而是借由编写实例汇编代码，演示32位和64位的x86处理器下的诸多功能和行为，以及在处理器框架下，现代操作系统内核的一些细节和设计","text":"x86汇编指南-导读 关于本篇 本文是我写的一系列关于x86架构下，CPU的保护模式和汇编原理相关的博客的导读，这些博客相互独立，但是为了方便阅读和索引，我在这里做了个目录。这些博客没有过度深究汇编器实现的具体细节，而是借由编写实例汇编代码，演示32位和64位的x86处理器下的诸多功能和行为，以及在处理器框架下，现代操作系统内核的一些细节和设计 我选用的汇编器是NASM，一个很有名的跨平台x86汇编器，所有的代码都在Ubuntu Server 20下运行通过了 安装环境 安装NASM 安装GNU编译工具 前置知识 不面向完全新手，最好有一些C的基础，不然很难理解 基础硬件，处理器和不同处理器的差异 内存模型，大端小端，反码补码 调试技术 8086实模式保护模式，寻址和外设 编译流程 必要的内核知识 汇编速成3篇 主要是快速入门，消除恐惧，看看到底是什么东西，具体的各个细节我放到例子里了 速成 控制流和子程序 宏和标准宏 例子 以下实例帮助了解nasm的各个方面，建议顺序阅读，也可以单篇阅读（我每篇都针对额外知识点做了link和讲解） 部分来自官方文档，部分来自自己代码 一般篇15 hello 模块化 调用规范和c联动 系统调用 命令行参数 ld的使用 fib和递归结构的数学基础 强大的宏，处理字符串 简单驱动 数学计算，主要是浮点数 并行和饱和计算 局部变量和栈帧 编写跨平台代码 同时使用gas和nasm，看二进制差异 make的使用和条件编译 os专篇8 学习使用qemu mbr 使用nasm操作grub cpu的任务模型和多任务实现 简单的显示驱动 页表深究 可执行文件深究和elf 初识缓存技术 安全专篇3 shellcode的编写 溢出漏洞模型 调试汇编和逆向工程 进阶知识 纯nasm编写一个程序 hurlex内核 改写xv6 阅读NASM文档 阅读Intel文档 速查表 一个link，指向自己写的简易wiki","categories":[{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/categories/%E6%B1%87%E7%BC%96/"}],"tags":[{"name":"x86","slug":"x86","permalink":"http://yoursite.com/tags/x86/"},{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"动态规划专栏-导读","slug":"algorithm/dynamic-programming/dynamic-programming-guide","date":"2020-09-17T05:13:55.000Z","updated":"2021-07-22T01:19:58.364Z","comments":true,"path":"2020/09/17/algorithm/dynamic-programming/dynamic-programming-guide/","link":"","permalink":"http://yoursite.com/2020/09/17/algorithm/dynamic-programming/dynamic-programming-guide/","excerpt":"","text":"动态规划专栏-导读 什么是动态规划 初识动态规划","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划专栏","slug":"算法/动态规划专栏","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E6%A0%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Dijkstra算法","slug":"algorithm/data-structure/graph-theory/graph-theory-dijkstra-algorithm","date":"2020-09-05T13:18:22.000Z","updated":"2021-07-22T01:19:58.362Z","comments":true,"path":"2020/09/05/algorithm/data-structure/graph-theory/graph-theory-dijkstra-algorithm/","link":"","permalink":"http://yoursite.com/2020/09/05/algorithm/data-structure/graph-theory/graph-theory-dijkstra-algorithm/","excerpt":"Dijkstra算法求解最短路径问题 Dijkstra算法使用类似BFS的方法解决赋权图的单源最短路径问题 Dijkstra算法使用贪心策略和动态规划 作者名字很难念","text":"Dijkstra算法求解最短路径问题 Dijkstra算法使用类似BFS的方法解决赋权图的单源最短路径问题 Dijkstra算法使用贪心策略和动态规划 作者名字很难念 最短路径问题 最短路径问题是图论中的一个非常经典且历史悠久的问题，其目的在于找出某个图结构中的两顶点之间的最短路径 最短路径问题拥有4种常见形式，每种都有自己的算法： 施工中…","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论专栏","slug":"算法/数据结构/图论专栏","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E8%AE%BA%E4%B8%93%E6%A0%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"图的搜索算法","slug":"algorithm/data-structure/graph-theory/graph-theory-search","date":"2020-09-04T06:10:24.000Z","updated":"2021-07-22T01:19:58.363Z","comments":true,"path":"2020/09/04/algorithm/data-structure/graph-theory/graph-theory-search/","link":"","permalink":"http://yoursite.com/2020/09/04/algorithm/data-structure/graph-theory/graph-theory-search/","excerpt":"图的深度优先搜索和广度优先搜索 搜索问题是图的众多算法中最核心最重要的，几乎所有图论算法都依赖图的搜索 图的搜索算法是判定连通性的重要工具","text":"图的深度优先搜索和广度优先搜索 搜索问题是图的众多算法中最核心最重要的，几乎所有图论算法都依赖图的搜索 图的搜索算法是判定连通性的重要工具 本文是系列文章的其中一篇，关于前后文请参见图论专栏-导读 图的搜索问题 图的搜索问题是图论的最基本问题，如果不能有效访问数据，那么数据结构将毫无意义，所谓的算法也会成为空谈，所以必须有一种有效的算法来搜索图所持有的数据。给定一个图，按照某种搜索方法，沿着图中的边对图中的所有顶点访问一次且仅访问一次，称为图的遍历 图的搜索算法主要有两种：深度优先搜索（Depth-First-Search，简称DFS）和广度优先搜索（Breadth-First-Search，简称BFS） 无论是深度优先搜索还是广度优先搜索，几乎所有的图论搜索算法都属于一种叫做优先级搜索的抽象策略。在图的存储结构及封装一文中，我们通过检查当前顶点的所有连通边（也就是adj()方法），来获取各类性质，在搜索算法中，我们的想法是沿着某顶点的连通边，过渡到下一个顶点，从而达到搜索整个图的目的。对BFS来说，其优先考虑最早发现的顶点（先扫描离起点近的），而DFS则关注最后发现的顶点 注意树其实是一种特殊的图，所以图的搜索和树的搜索很相似，DFS类似树的先序遍历，BFS类似树的中序遍历 从辅助结构的选型上讲，DFS和BFS其实是记录型结构（栈）和缓冲型结构（队列）的不同实现 深度优先搜索 深度优先是一种回溯性算法，其本质结构是栈构成的记录型结构，常规实现是通过递归，在给出代码之前，我们可以看一个小故事 迷宫问题 迷宫问题是一个希腊神话的古老遗产，讲的是米诺斯国王为了囚禁儿子，一个半人半牛怪物的弥诺陶洛斯所建造的一座无法逃出的监牢。假设把你丢进了迷宫，那么摆在你面前只有两个下场，被迷宫困住，去见马克思，或者寻找一种方式，逃出生天。最经典的走迷宫方法是“绳子策略”： 准备一根绳子，绳子的一端放在你的起点，另一端抓在你的手里 准备一支粉笔，走过的路都做上标记 遇到岔路时，挑选一个没有标记的路走进去 如果继续遇到岔路，重复3；如果遇到死胡同，则顺着绳子回到上一个岔路，重复3 如果返回的岔路口的所有路都做过了标记（全是死胡同），则顺着绳子继续回到上一个岔路 在这个策略里，绳子保证了遇到死胡同时可以找到回去的路，而标记保证了你不会重复进去一条已经走过的死胡同，于是在你不断地尝试各个路径，并在失败后使用绳子回溯的过程中，你尽可能尝试了尽可能多的路径，并最终找到出口逃出生天，或者尝试了所有路径，发现没有出口（太惨了）。 深度优先搜索算法 到此为止，深度优先遍历的核心策略已经出来了，为了实现DFS，我们需要： 一根绳子：一个记录型结构，这个FIFO很显然就是栈结构 一支粉笔：一张表（数组或者散列），用来标记每条边是否已经访问。我们走迷宫时最担心的不是找不到出口，而是绕圈圈，走重复的路径，搜索图时一样，就怕加入了回路变成出不去的死循环，“粉笔”就是用来做这个的关键机构 一点耐心：每次都尝试走尽可能远的路径，直到找到出口，或者碰壁回溯 因为我们采用递归结构来实现DFS，递归算法天然持有一个栈（函数调用和返回的机制和绳子回溯的作用类似），所以我们只需要一个marked[]数组来标记，下来来看一个完整的例子： 我们建立了一个简单的迷宫，我们将其连通模型，抽象成一个6个顶点和8条边的的无向图 我们的任务是从顶点0出发，使用DFS访问所有的顶点 从顶点0出发，未访问边3条，通过(0,2)访问顶点2，访问过的顶点和边被我标记了赭红色（邻接点的访问是随机的） 从顶点2出发，未访问边3条，通过(1,2)访问顶点1 从顶点1出发，未访问边1条，通过(0,1)访问顶点0 此时发现顶点0已被标记，且顶点1已无可访问边，回退到顶点2 从顶点2出发，未访问边2条，通过(2,3)访问顶点3 从顶点3出发，未访问边2条，通过(3,5)访问顶点5 从顶点5出发，未访问边1条，通过(0,5)访问顶点0 此时发现顶点0已被标记，且顶点5已无可访问边，回退到顶点3 从顶点3出发，未访问边1条，通过(3,4)访问顶点4 所有顶点被访问，遍历结束 生成树和生成森林 在DFS的过程中，我们会得到一棵遍历树，称为深度优先生成树（希望你还记得生成树的定义），图的DFS遍历树的先序遍历序列和其DFS序列是一致的，本例中的DFS生成树如下，它的遍历序列是[0,2,1,3,5,4]，和图的DFS序列一致： 值得一提的是，深度遍历生成树不是唯一的，其受存储结构的影响（邻接矩阵的生成树是唯一的，但邻接表不是，因为邻接表的邻接点无序），下面是本例的另一种DFS生成树： 这里看到了经典的DFS轨迹图形，也就是所谓的“一棍子捅到底”，可以清晰看出，只要条件合适，DFS算法会尽可能深入地尝试一条路径 在非连通图中的例子 上面的例子是一个无向的连通图，如果遇到非连通图，其实也是一样的，把它的几个连通分量抓出来，看作一个独立的连通图，使用DFS输出后，获得一个生成森林： 在有向图中的例子 有向图的DFS和无向图的DFS没有区别，只是有向图更容易遇到“死胡同”（因为强连通性可没那么好满足），从而很容易遍历到一半断片了，完了最后是一个生成森林。示例如下： DFS本质是一样的，没有区别 代码实现 代码已经上传graph-algorithm-kit，用的存储结构的那套代码，方便和上一篇博客联系（其实是作者偷懒），可以配合本节阅读，为了节约篇幅，本篇只贴出核心部分 按照我们在图结构的封装一节中的做法，依旧是采用Graph+ListGraph的分离式设计，应用代码都放在工具类Graphs里。这里是Graphs中关于DFS的两个主要方法：深度优先搜索DepthFirstSearch和深度优先遍历DepthFirstTraverse，主体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public abstract class Graphs &#123; // 判定通路src-&gt;tar是否存在，可达则返回true public static boolean depthFirstSearch(Graph graph, Integer src, Integer tar) &#123; // 判断顶点越界 validateVertex(src,graph); validateVertex(tar,graph); // DFS List&lt;Integer&gt; marked = new ArrayList&lt;&gt;(); dfs(graph,marked,src); return marked.contains(tar); &#125; public static List&lt;Integer[]&gt; depthFirstTraverse(Graph graph, Integer src) &#123; // 判断顶点越界 validateVertex(src, graph); // 如果起点src为空，默认为顶点0出发 int first = Objects.requireNonNullElse(src, 0); // 结果集（我们的结果很有可能是一个生成森林，所以使用二维表） List&lt;Integer[]&gt; results = new ArrayList&lt;&gt;(); // 设置标记集 List&lt;Integer&gt; marked = new ArrayList&lt;&gt;(); // 优先访问起点，再访问其它顶点 for (int i = first; i &lt; first + graph.V(); i++) &#123; int n = i % graph.V(); if (!marked.contains(n)) &#123; int boundary = marked.size(); dfs(graph, marked, n); Integer[] buf = new Integer[marked.size() - boundary]; marked.subList(boundary, marked.size()).toArray(buf); // 每次都只将新加入的结点写入数组，boundary就是标记新顶点用的 results.add(buf); &#125; &#125; // 返回结果 return results; &#125; // 递归函数 private static void dfs(Graph graph, List&lt;Integer&gt; marked, Integer v) &#123; // 标记顶点 marked.add(v); // 递归访问未标记顶点 for (Integer i : graph.adj(v)) if (!marked.contains(i)) dfs(graph, marked, i); &#125; // 判定顶点合法性的工具函数 public static void validateVertex(int v, Graph graph) &#123; if (v &lt; 0 || v &gt;= graph.V()) &#123; throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (graph.V() - 1)); &#125; &#125;&#125; 测试用例1，对一个无向图进行遍历和搜索： 12345678910111213141516171819202122232425262728293031323334public class TestSearch &#123; @Test public void testGraphDFS() &#123; // 构造无向图 Graph graph = new ListGraph(6); graph.addEdge(0, 1); graph.addEdge(0, 2); graph.addEdge(0, 5); graph.addEdge(2, 3); graph.addEdge(2, 4); graph.addEdge(4, 3); graph.addEdge(3, 5); graph.addEdge(1, 2); // 从顶点0出发 List&lt;Integer[]&gt; res = Graphs.depthFirstTraverse(graph, 0); System.out.println(\"the forest from 0: \"); for (Integer[] is : res) &#123; System.out.println(Arrays.toString(is)); &#125; // 从顶点4出发 List&lt;Integer[]&gt; res1 = Graphs.depthFirstTraverse(graph, 4); System.out.println(\"the forest from 4: \"); for (Integer[] is : res1) &#123; System.out.println(Arrays.toString(is)); &#125; // 验证可达路径&lt;1,5&gt; System.out.println(\"the path 1-&gt;5: \" + Graphs.depthFirstSearch(graph, 1, 5)); // 验证可达路径&lt;2,4&gt; System.out.println(\"the path 2-&gt;4: \" + Graphs.depthFirstSearch(graph, 2, 4)); &#125;&#125; 输出结果： the forest from 0: [0, 1, 2, 3, 4, 5] the forest from 4: [4, 2, 0, 1, 5, 3] the path 1-&gt;5: true the path 2-&gt;4: true 这里用的图其实就是上文的迷宫，可以看到从不同顶点出发， 会有不同的结果，但是都获得了一棵生成树，而且我们的迷宫是一个连通图，无论是1-&gt;5还是2-&gt;4都是可达的： 测试用例2，对一个非连通的有向图进行遍历和搜索： 123456789101112131415161718192021222324252627282930313233public class TestSearch &#123; @Test public void testDigraphDFS() &#123; // 构造有向图 Digraph digraph = new ListDigraph(8); digraph.addEdge(4, 0); digraph.addEdge(1, 2); digraph.addEdge(1, 5); digraph.addEdge(5, 2); digraph.addEdge(2, 6); digraph.addEdge(3, 6); digraph.addEdge(3, 7); // 从顶点0出发 List&lt;Integer[]&gt; res = Graphs.depthFirstTraverse(digraph, 0); System.out.println(\"the forest from 0: \"); for (Integer[] is : res) &#123; System.out.println(Arrays.toString(is)); &#125; // 从顶点1出发 List&lt;Integer[]&gt; res1 = Graphs.depthFirstTraverse(digraph, 1); System.out.println(\"the forest from 1: \"); for (Integer[] is : res1) &#123; System.out.println(Arrays.toString(is)); &#125; // 验证可达路径&lt;1,6&gt; System.out.println(\"the path 1-&gt;6: \" + Graphs.depthFirstSearch(digraph, 1, 6)); // 验证可达路径&lt;1,7&gt; System.out.println(\"the path 1-&gt;7: \" + Graphs.depthFirstSearch(digraph, 1, 7)); &#125;&#125; 输出结果： the forest from 0: [0] [1, 2, 6, 5] [3, 7] [4] the forest from 1: [1, 2, 6, 5] [3, 7] [4, 0] the path 1-&gt;6: true the path 1-&gt;7: false 本测试的用例是一个不连通的有向图，有向图的遍历一般比无向图麻烦，因为它的连通条件比无向图苛刻，更容易产生“死胡同”，所以有向图一般都是生成森林，且起点不同对这个森林是有影响的： 以顶点0为起点和以顶点1为起点，是有区别的，这和我们的算法实现，以及存储结构有关 DFS的时空分析 在空间上，DFS虽然只创建了一个标记集，同时自己是一个递归算法，持有一个调用栈，所以空间复杂度为O(|V|) 在时间上，DFS算法的复杂度和其选用的存储结构有关，如果使用的是邻接矩阵，每次调用adj()方法时，需要访问|V|个顶点，所以整体空间复杂度为O(|V|**2)，如果是邻接表存储的图，每次调用adj()方法时，需要访问|E|个顶点，访问所有顶点的时间为O(|V|)，所以邻接表的整体时间消耗为O(|V|+|E|) 广度优先搜索 看完DFS的例子，相比对图的搜索已经有了一个很好的概念，再来讲BFS（Breadth First Search，广度优先搜索）就很容易了。前文提过，DFS和BFS都采用的优先级策略，DFS关注的是最后被发现的顶点，而BFS则是考虑最早被发现的顶点 广度优先搜索算法 BFS类似树的层次遍历模型，对于起点v，我们会先依次访问v的“儿子们”（也就是v的邻接点），再依次访问“孙子们”（v的邻接点的邻接点），这种分层次的查找过程，就是广度优先。与DFS展现出的“探索性”不一样，BFS更多的是一种扩散性（或者说侵蚀性），我们一起来看个例子： 我们依旧构造一个无向图，我们这次从顶点1出发，第1层次为1： 第2层次为0,5： 第3层次为2,4,6： 第4层次为3,7： 和DFS一样，在BFS中，我们最终可以获得一棵BFS生成树： BFS生成树的层次遍历和BFS序列是一致的 代码实现 和DFS的代码类似，使用队列作为缓冲结构（这里的缓冲场景指，记忆正在访问的顶点的下一层顶点），而不是栈，所以这里没有递归结构，也没有回退，只有迭代队列，直到遍历整张表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public abstract class Graphs &#123; // 广度优先搜索 public static boolean breadthFirstSearch(Graph graph, Integer src, Integer tar) &#123; // 判断顶点越界 validateVertex(src, graph); validateVertex(tar, graph); // BFS List&lt;Integer&gt; marked = new ArrayList&lt;&gt;(); bfs(graph, marked, src); return marked.contains(tar); &#125; // 广度优先遍历 public static List&lt;Integer[]&gt; breadthFirstTraverse(Graph graph, Integer src) &#123; // 判断顶点越界 validateVertex(src,graph); // 设置起点 int first = Objects.requireNonNullElse(src, 0); // 结果集 List&lt;Integer[]&gt; results = new ArrayList&lt;&gt;(); // 标记集 List&lt;Integer&gt; marked=new ArrayList&lt;&gt;(graph.V()); // 优先访问起点，再访问其它顶点 for (int i = first; i &lt; first + graph.V(); i++) &#123; int n = i % graph.V(); if (!marked.contains(n)) &#123; int boundary = marked.size(); bfs(graph, marked, n); Integer[] buf = new Integer[marked.size() - boundary]; marked.subList(boundary, marked.size()).toArray(buf); results.add(buf); &#125; &#125; // 返回结果 return results; &#125; private static void bfs(Graph graph, List&lt;Integer&gt; marked, Integer src) &#123; // 直接访问起点，将其标记并置入队列 Queue&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); marked.add(src); queue.add(src); // 迭代整张图 while (!queue.isEmpty()) &#123; for (Integer i:graph.adj(queue.poll())) &#123; if (!marked.contains(i)) &#123; marked.add(i); queue.add(i); &#125; &#125; &#125; &#125; // 判定顶点合法性的工具函数 public static void validateVertex(int v, Graph graph) &#123; if (v &lt; 0 || v &gt;= graph.V()) &#123; throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (graph.V() - 1)); &#125; &#125;&#125; 测试用例1，构造一个2个分量的无向图，分别从顶点1和顶点2开始遍历，下面是原图： 完整用例代码： 12345678910111213141516171819202122232425262728293031323334353637public class TestSearch &#123; @Test public void testGraphBFS() &#123; // 构造图 Graph graph = new ListGraph(10); graph.addEdge(0, 1); graph.addEdge(0, 4); graph.addEdge(1, 5); graph.addEdge(2, 5); graph.addEdge(6, 5); graph.addEdge(2, 6); graph.addEdge(3, 6); graph.addEdge(3, 2); graph.addEdge(3, 7); graph.addEdge(6, 7); graph.addEdge(9, 8); // 从顶点0出发 List&lt;Integer[]&gt; res = Graphs.breadthFirstTraverse(graph, 1); System.out.println(\"the forest from 1: \"); for (Integer[] is : res) &#123; System.out.println(Arrays.toString(is)); &#125; // 从顶点4出发 List&lt;Integer[]&gt; res1 = Graphs.breadthFirstTraverse(graph, 2); System.out.println(\"the forest from 2: \"); for (Integer[] is : res1) &#123; System.out.println(Arrays.toString(is)); &#125; // 验证可达路径&lt;1,5&gt; System.out.println(\"the path 4-&gt;5: \" + Graphs.breadthFirstSearch(graph, 4, 5)); // 验证可达路径&lt;2,4&gt; System.out.println(\"the path 1-&gt;9: \" + Graphs.breadthFirstSearch(graph, 1, 9)); &#125;&#125; 输出结果： the forest from 1: [1, 0, 5, 4, 2, 6, 3, 7] [8, 9] the forest from 2: [2, 5, 6, 3, 1, 7, 0, 4] [8, 9] the path 4-&gt;5: true the path 1-&gt;9: false 看官可以像DFS那节的捕捉图一样，自己画一下BFS的生成森林，体验一下队列是怎么在BFS中起作用的 测试用例2，构造一个2个分量的有向图，分别从顶点0和顶点1开始遍历，下面是原图： 123456789101112131415161718192021222324252627282930313233public class TestSearch &#123; @Test public void testDigraphBFS() &#123; // 构造有向图 Digraph digraph = new ListDigraph(8); digraph.addEdge(4, 0); digraph.addEdge(1, 2); digraph.addEdge(1, 5); digraph.addEdge(5, 2); digraph.addEdge(2, 6); digraph.addEdge(3, 6); digraph.addEdge(3, 7); // 从顶点0出发 List&lt;Integer[]&gt; res = Graphs.breadthFirstTraverse(digraph, 0); System.out.println(\"the forest from 0: \"); for (Integer[] is : res) &#123; System.out.println(Arrays.toString(is)); &#125; // 从顶点1出发 List&lt;Integer[]&gt; res1 = Graphs.breadthFirstTraverse(digraph, 1); System.out.println(\"the forest from 1: \"); for (Integer[] is : res1) &#123; System.out.println(Arrays.toString(is)); &#125; // 验证可达路径&lt;1,6&gt; System.out.println(\"the path 1-&gt;6: \" + Graphs.breadthFirstSearch(digraph, 1, 6)); // 验证可达路径&lt;1,7&gt; System.out.println(\"the path 1-&gt;7: \" + Graphs.breadthFirstSearch(digraph, 1, 7)); &#125;&#125; 输出结果： the forest from 0: [0] [1, 2, 5, 6] [3, 7] [4] the forest from 1: [1, 2, 5, 6] [3, 7] [4, 0] the path 1-&gt;6: true the path 1-&gt;7: false 可以看出，有向图的BFS也是具有差异性的 BFS的时空分析 BFS的时空复杂度和DFS的类似，不过是将辅助结构从栈换成了队列，具体如下： DFS的空间复杂度为O(|V|) 采用邻接矩阵的DFS的时间复杂度为O(|V|**2) 采用邻接表的DFS的时间复杂度为O(|V|+|E|) BFS和单源最短路径问题 设一个非带权图G=(V,E)，其顶点u和顶点v的最短路径d(u,v)为从顶点u和顶点v的所有路径中最少的边数，若不存在通路则d(u,v)=∞ 使用BFS可以很容易解决单源最短路径问题（单源表示只有一个确定起点和一个确定终点），因为BFS是层次模型，它会按照离起点由近到远的优先级来将顶点纳入访问集，观察下面的广度优先生成树： 从顶点1和顶点2有4条简单通路，分别是： 1,5,2 1,5,6,2 1,5,6,3,2 1,5,6,7,3,2 由于BFS的策略，1,5,2早于其它路径（比如1,5,6,2）被纳入访问集（也就是会尽可能靠近起点），所以可以在BFS生成树里看到，顶点2在树的第3层，只要简单给层次数做个减法就可以得到最短路径，即d(1,2)=2 总结 DFS和BFS是几乎所有图论算法的基础，因为搜索算法讨论的是图的连通性问题，连通性是图的本质属性（个体产生相互作用，才能形成关系图），其本质区别其实是栈和队列在数据结构特性上的区别： 栈是一种记录型结构，适合需要回溯的递归算法，所以DFS更具探索性，使用DFS遍历图，可以快速体系其整体性质 队列是一种缓冲型结构，可以很好地保存顶点之间的前后顺序，所以BFS更具层次性，其遍历图也是“一圈一圈”地“层层递进” 图的搜索算法是典型的小巧却异常强大的强应用算法，需好好掌握 行文匆忙，如果看到错误或代码bug，还请issue或在评论区指出(*/ω＼*) 参考 wiki-图论 Algorithms, 4th Edition 离散数学 数据结构","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论专栏","slug":"算法/数据结构/图论专栏","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E8%AE%BA%E4%B8%93%E6%A0%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"图的存储结构及封装","slug":"algorithm/data-structure/graph-theory/graph-theory-storage-structure","date":"2020-08-19T14:10:05.000Z","updated":"2021-07-22T01:19:58.364Z","comments":true,"path":"2020/08/19/algorithm/data-structure/graph-theory/graph-theory-storage-structure/","link":"","permalink":"http://yoursite.com/2020/08/19/algorithm/data-structure/graph-theory/graph-theory-storage-structure/","excerpt":"图的常见存储结构和封装 图的存储是这类数据结构的算法基础，又称物理结构，针对不同类型的图有不同的存储方案 在面向对象语言中，图可以通过封装来隔离各种存储结构以适应不同的场景，良好的存储结构封装是图算法的基础","text":"图的常见存储结构和封装 图的存储是这类数据结构的算法基础，又称物理结构，针对不同类型的图有不同的存储方案 在面向对象语言中，图可以通过封装来隔离各种存储结构以适应不同的场景，良好的存储结构封装是图算法的基础 阅读之前 本文是系列文章的其中一篇，关于前后文请参见图论专栏-导读 概念 所谓存储，就是设计一个结构，完整表示一个数据集 作为一种数据结构，如果想把图和其它的抽象数据结构（也就是ADT）来使用，就必须将其表示成某种有效的形式，也就是图的存储结构。按照离散数学中对图的定义形式G=(V,E)，想要设计一个存储结构来表示一个图的完整数据，就必须完整且准确地反应顶点集和边集的信息。由于图的结构多样，针对不同的使用场景，会出现不同类型的图（如构造高铁线路多用稀疏图，而网站拓扑多是稠密图），可以采用不用的存储方案，而且在实际使用中，不同的存储结构对程序的效率有较大影响，所以必须根据真实问题，调整所选用的存储结构 一般来说，无论是有向图还是无向图，其主要的存储方式只有两种： 邻接矩阵 邻接表 邻接矩阵属于图的顺序存储结构，邻接表属于链式存储结构 在此基础上，针对无向图和有向图的区别，对普通邻接表进行优化，可以得到两种新的数据结构，也就是十字链表和邻接多重表，这4种结构成为了图的基本存储结构 图的存储结构 如果不带特殊说明，我们讨论图论问题时，说的都是简单图，也就是不带自旋和平行边的图 本文部分地方混淆了边和弧的释义，一般来说，有向边称弧，无向边称边 1. 邻接矩阵 上文提过了，图G=(V,E)由一个顶点集和边集同时构成（不熟悉的旁友戳这里图的数学定义），所谓的邻接矩阵存储法，就是用一个一维数组存储图中的顶点信息，用一个二维数组存储图中的边信息（也就是各个顶点直接的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵，邻接矩阵同时也是数学上表示图论的最初方法（详见离散数学和矩阵论） 矩阵的构造有3点规则： 如果图有n个顶点，就构造一个n*n的二维数组map 如果第i个结点和第j个结点直接有边（也就是i-&gt;j或i&lt;-&gt;j），那么map[i][j]=1 如果第i个结点和第j个结点之间没有边，则map[i][j]=0 有向图的示例矩阵如下所示： 无向图的示例矩阵如下所示： 在这里你可以观测到无向图的邻接矩阵的对称性（也就是矩阵整体沿着[0][0]-&gt;[4][4]的斜线对称），0结点和1结点之间右边，所以[0][1]和[1][0]都是1，这也说明了，在结构上，无向图其实是有向图的一个特例（每条边同时拥有两个方向），在这个问题上衍生了一个矩阵压缩问题，在代码实现一节会详细提到 其实到这里有小伙伴要问了啊，矩阵数值的0和1是固定的吗？当然不是，你想取什么就取什么，只要能区分无边和有边就行了，同时在带权图中，这个0/1可以衍生为权重值，表示从结点m到结点n所需要的代价，下图是一个有向带权图的简单示例（有点丑别介意）： 在之前的图中，0表示没边，但是这里0是权重值的一种，所以“无边”改成了字符&quot;x&quot;，这个取值其实是比较随意的，看个人习惯 在这里需要最后提一个点，那就是邻接这个概念，如果你仔细观察上面的各个图的邻接矩阵，会发现，矩阵中的第i行数据，都是从i结点指出的边，第j列数据，都是指向j结点的边，这些边在图形中都是兄弟关系，所以称联结，联结边在图的遍历和搜索中是一个非常重要的概念。此外我在这边罗列了一些邻接矩阵表示法的一些性质和要点： 无向图的邻接矩阵一定是一个对称矩阵（且唯一），所以在存储时可以采取“上三角阵压缩法” 对于无向图，邻接矩阵的第i行/列的非零元素即第i个结点的度 对于无向图，邻接矩阵的第i行/列的非零元素即第i个结点的出/入度 简单应用时，通常直接使用二维数据来实现矩阵 稠密图适合采用邻接矩阵法 2. 邻接表 邻接矩阵在一开始就固定了图的大小，在存储稠密图时很给力，但是如果我们存储的是一个稀疏图，那么邻接矩阵就会浪费大量的存储空间，于是出现了另一种存储方案，也就是邻接表法，邻接表同时使用了顺序存储和链式存储，极大地减少了空间浪费 和邻接矩阵一样，邻接表也要完整表示图的顶点集和边集，在邻接表中，由一个数组来存储所有的顶点结点，这个数组称为顶点表（其中每个元素都代表了一个顶点），每个结点会带一个“小尾巴”，形式上一般是一个单链表，单链表中的元素为该顶点所持有的边，这条单链表称为边表（其中每个元素都代表了一条边），下图是一个无向图的邻接表示例： 可以看到邻接表极大减少了空间浪费，再看一个有向图的例子： 注意到这个5结点有一个自环（或者说自旋） 我们这边观察到每个结点的单链表似乎是有序的，但其实顺序在图结构里没有意义，这个“边集”的单链表你想怎么排序都行，实现时通常采用迭代器 和邻接矩阵一样，我在这里罗列了一些邻接表的性质和要点： 如果是无向图，每条边会在连接表中出现两次，所以存储空间为O(|V|+2*|E|)，而如果时有向图，每条有向边只出现一次，存储为O(|V|+|E|)，在实际编程中，我们会将无向图看作有向图的特殊形式，大多数时候在实现上不做区分 对于稀疏图，采用邻接表存储可以极大程度节约空间 对于“邻接”这个概念，在邻接表中，如果想访问一个顶点的所有边是非常容易的，只要遍历它所携带的那条链表（边表）就行了，链表上的每个元素的next的实意是“当前边在附着点上的兄弟边”。但是如果想确定两个顶点是否存在边，就需要扫描整个表了，而在邻接矩阵中，只要访问[i][j]是否=1即可（这就是邻接矩阵作为完全顺序存储的优势，虽然空间上不讨好，但是读写很快） 同样的，在有向图中，确定一个顶点的出度只要遍历其边表（也就是所持有的单链表）即可，但是如果要确定其入度，则要遍历全表 上文提过，图的邻接表表示并不唯一，因为每个顶点所携带的表示边集的单链表是无序的，其次序取决于建立邻接表时数据输入序列和所用的算法 对于实际应用来说，邻接矩阵和邻接表是最常见的两种图的存储方式，但是针对邻接表的一些结构问题，衍生出两种优化型的邻接表结构，通常不做要求，理解即可（因为形式上有点复杂，不是很好理解，实际的使用频率也不是特别高），下文会简单讲述一下十字链表和邻接多重表 3. 十字链表 十字链表是邻接表针对有向图的一种优化链式存储结构，为的是解决邻接表的出入度计算问题。十字链表是一种模拟邻接矩阵的类邻接表结构，在实现上可以看作是邻接表和逆邻接表的合体，兼顾了邻接表对稀疏图的有效空间利用和邻接矩阵行列快速求解出入度的优势 在这里我给出了一个有向图的例子来解释一下十字链表的由来，图中分别是有向图的图例，邻接矩阵表示，邻接表表示和逆邻接表： 通常有向图的邻接表顶点A持有的表示弧集的单链表代表的是出弧（由A指向某个顶点B的弧），逆邻接表所表示的则是入弧（由某个顶点B指向A的弧），前者容易计算顶点出度，后者容易计算顶点入度 前文在邻接表的一节中提过，对于有向图的邻接表来说，计算某个顶点的出度是很容易的，只要遍历其持有的单链表（弧集）即可，但是计算其入度则要遍历整个表，这就非常蛋疼了（对于逆邻接表则是反的，很容易计算顶点的入度，但是计算出度要遍历全表），而在另一边，使用邻接矩阵的有向图，顶点i的出度为[i][*]的有效和，入读为[*][i]的有效和，以上图的顶点1为例： 出度=行和=[1][0]+[1][1]+[1][2]+[1][3]=0 入度=列和=[0][1]+[1][1]+[2][1]+[3][1]=2 为了模拟邻接矩阵这种行和列的关系，我们将邻接表和逆邻接表结合，就可以得到十字链表了 对于十字链表来说，依旧是采用顶点数据和弧集链表的方式，顶点集和弧集的结点结构如下： 十字链表的弧结点是有向图的邻接表和逆邻接表中弧结点的组合，代表一条弧（也就是有向边），其各部分释义如下： tailvex/headvex：这条弧为tailvex-&gt;headvex（也就是由tailvex指向headvex，vex是顶点的意思，有向图中每条弧的方向都是弧尾tailvex指向弧头headvex） hlink：指向弧头相同的下一条弧（等价于逆邻接表中的nextarc） tlink：指向弧尾相同的下一条弧（等价于邻接表中的nextarc） 十字链表的顶点结点是有向图的邻接表和逆邻接表中顶点结点的组合，其同时持有两个单链表起点，其各部分释义如下： data：表示其实体数据，一般是结点id firstin/firstout：以该顶点为弧头/弧尾的第一条弧 下图是上文图例的十字链表表示： 值得注意的是，顶点集依旧是顺序存储的 注意观察下图的染色部分，通过剥离顶点结点的in链和out链，我们可以分别把十字链表退化成邻接表和逆邻接表： 剥离out方向：十字链表退化成邻接表 剥离in方向：十字链表退化成逆邻接表 这里罗列十字链表的几个性质和要点： 十字链表是一种针对有向图的链式存储结构 在十字链表中，对于一个顶点vi，既可以容易找到vi为尾的弧，又容易找到vi为头的弧，因而容易求得顶点的出度和入度，而无需像在邻接表中那样遍历全表 图的十字链表表示不是唯一的，但是一个十字链表可以确定一个图 一个有向图的十字链表可以退化成邻接表和逆邻接表 在Linux内核中有广泛应用 4. 邻接多重表 十字链表是针对有向图的一种优化结构，那么邻接多重表就是针对无向图的一种优化链式存储结构，其核心思想是多链表结点重叠结构 我们前文提到过，无向图其实可以看作有向图的一种特殊情况，无向图的每条边，其实都可以看作两条平行的弧，因此在无向图的邻接表中，每条边会出现两次，这就当我们需要新增或者删除某条边时，需要遍历全表，这就显得非常不环保，所以出现了邻接多重表，将无向图的邻接表中中同一条边的两个副本重叠，从而减少遍历负担 我们来看一个无向图的图例及其邻接表表示： 可以清楚地看到，无向图的边数为6，而其邻接表的边结点数为12，每条边都出现了两次，它们表示的其实是同一条边，这就其实造成了一种冗余，也是我们删除困难的诱因，所以我们重新设计一下边结点的结构，参考双向链表的设计，使其能同时链接在两个链表（每天链表都表示某个顶点vi的所有边，这其实就是将我们的边的两端设置成其所连接的两个顶点）中，完整结构如下： 顶点结点和邻接表中没有区别，主要是边结点，它其实就是把邻接表中的一条边的两个结点缝合在一个结点里，各个域的释义如下： ivex/jvex：为该边依附的两个顶点id ilink：指向下一条依附于顶点ivex的边（也就是邻接的概念，指向兄弟边，目的是方便遍历） jlink：指向下一条依附于顶点jvex的边（也就是邻接的概念，指向兄弟边，目的是方便遍历） 通过这个结构，使得每个边结点同时链接在两个链表中，下面是上文图例的临接多重表的表示： 可以观察到，边结点的数目由之前的12个降到了6个，在这里每条边只出现了一次，也就是说每条边只有一个边结点，于是在删除和新增边的时候，就没有了之前奇奇怪怪的扫描问题 同样地，邻接多重表可以像十字链表拆分邻接表那样，拆分成其最初的邻接表，这里留给读者大人们自己实现一下，就当是熟悉邻接多重表的小练习了（其实是作者偷懒XD） 这里罗列一下邻接多重表的几个性质和要点： 邻接多重表就是针对无向图的一种优化链式存储结构 邻接多重表是为了解决无向边的邻接表在删除边时需要扫描全表的问题 邻接多重表中每条边只有一个结点 至此 子图的表示问题 子图的问题其实在图的存储中不是什么难题，甚至完全不需要关心，就比如下图是一个非连通图（树可以看作一种特殊的图，森林其实就是一幅图），依旧采用邻接表法，和一般表示没有区别： 在处理全图遍历的时候可能会有一点点不同，但是很容易调整，这不是本篇的重点 图的封装和代码实现 由于图处理的相关算法种类众多，而且图的存储结构对算法的实现和效率有很大的影响，所以图类数据结构和算法设计的首要目标就是把把图的表示和实现分离开来，落实到代码上就是分层次设计图的表示，图的存储和处理算法实现。首先要说明一下，图论真的是相当灵活和多变的结构，所以JDK的集合框架没有提供通用图接口（因为实在是没有“万能”的图结构代码模板），而在实际的编程中，也不会煞费苦心设计一个类似java.util.List一样的接口类，经常就直接写了个二维数组就开始实现算法了，所以没必要煞费苦心去搞什么抽象图结构代码。想把代码写复杂很容易，但是写简单却很难，图论算法的一个Magic的地方就是，一些很少的性质，就可以实现很复杂的图的构造和优化搜索，本文在实现上，体现图论的结构核心为主，涉及的一部分oop只是我组织代码用的，重点应该是还是数据结构本身 本节的代码请参见graph-algorithm-kit，这也是本文所在专栏的基础代码，演示为主，为了表达简洁，砍掉了很多内容，实际应用请根据需求调整 图结构设计的重点就是把图的表示和实现分离开来，在正式编写代码之前，我们可以先确定一下一个有效的图结构，必须完成哪些功能： 有效表示顶点集和边集 图是否存在边&lt;v,w&gt; 列出顶点v的邻接边 输出某顶点的第一个邻接点 输出某顶点的下一个邻接点 插入/删除一个顶点 插入删除一条边 获得/重置某条边的权重值 尽管这么说，其实很多功能对于一个最小功能的图结构是不需要的，比如删除一个顶点，其实很多时候并不是一个必要功能，于是我们定义的最小图结构代码如下所示： 12345678910111213141516171819// 一个抽象的无向图public interface Graph &#123; // 返回G=(V,E)的顶点数和边数 int V(); int E(); // 新增一条边 void addEdge(int v, int w); // 获取某个顶点的所有邻接点 Iterable&lt;Integer&gt; adj(int v);&#125;// 一个抽象的有向图图public interface Digraph extends Graph &#123; // 输出一张逆向图 Digraph reverse();&#125; 没错，如你所见，我们定义的最小图结构其实就两个计数方法和两个核心方法，其中adj()方式是最核心的方法，这涉及了邻接结构的核心和图类算法的短视性 短视性，又称局部可见性，是链式结构的常见属性，指程序在扫描链式结构时，通常同时只能查看当前结点和其直接相连的结点，类似“盲人摸象”，只能见局部，不可见整体，但是正是由于这种特性，可以和递归算法很好搭配，也造成了图论算法的简洁性，尤其是操作成千上万顶点的图时尤其明显 虽然我一直在讲无向图是一种特殊的有向图balabala，但是在实现的时候，我还是把它们分开了，尽管无向图的代码随便改两行就可以拿到有向图那边用了，但是为了条理更清晰，我还是分开写了 在上文放出的repo里，一共有两个核心接口Graph和Digraph，实现了8个存储类ListDigraph，ListGraph，MatrixDigraph，MatrixGraph，MultiListGraph，OrthogonalDigraph，SetDigraph，SetGraph和一个工具类Graphs，备注如下 名称 继承关系 实现结构 描述 interface Graph - 接口 无向图接口 interface Digraph extends Graph 接口 有向图接口，继承自无向图 abstract class Graphs - 抽象类 工具类，封装各种对图操作函数 class ListDigraph implements Digraph 类 有向图的邻接表存储结构 class ListGraph implements Graph 类 无向图的邻接表存储结构 class MatrixDigraph implements Digraph 类 有向图的邻接矩阵存储结构 class MatrixGraph implements Graph 类 无向图的邻接矩阵存储结构 class MultiListGraph implements Graph 类 无向图的邻接多重表存储结构 class OrthogonalDigraph implements Digraph 类 有向图的十字链表存储结构 class SetDigraph implements Digraph 类 有向图的邻接集存储结构 class SetGraph implements Graph 类 无向图的邻接集存储结构 这些方便演示，都是简单图（无自环无平行边）且不带权 由于条目比较多，这里只演示ListGraph，其余的请自行阅读代码 ListGraph是无向图的邻接表存储结构（个人比较常用的，因为实现比较清晰，比邻接矩阵更环保一点），其完整的类签名如下： 1public class ListGraph implements Graph &#123;&#125; 其所实现的Graph接口，完整如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// 一个抽象的无向图G=(V,E)public interface Graph &#123; int V(); // 顶点数 int E(); // 边数 void addEdge(int v, int w); // 新增一条边 Iterable&lt;Integer&gt; adj(int v); // 获取某个顶点的所有邻接点 // 静态内部类，封装了几个工具函数 static class GraphUtils &#123; // 判定顶点索引是否越界（本例中，顶点id就是） public static void validateVertex(int v, int V) &#123; if (v &lt; 0 || v &gt;= V) &#123; throw new IllegalArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1)); &#125; &#125; // 将图以邻接表字符串的形式打印 public static String printAdjacencyList(Graph g) &#123; StringBuilder sb = new StringBuilder(\"the graph of \" + g.getClass().getSimpleName() + \" : \"); sb.append(g.V()).append(\" vertices, \").append(g.E()).append(\" edges \\n\"); for (int i = 0; i &lt; g.V(); i++) &#123; sb.append(\"[\").append(i).append(\"]\"); for (Integer integer : g.adj(i)) &#123; sb.append(\"-&gt;\").append(integer); &#125; sb.append(\"\\n\"); &#125; return sb.toString(); &#125; // 将图以邻接矩阵字符串的形式打印 public static String printAdjacencyMatrix(Graph g) &#123; StringBuilder sb = new StringBuilder(\"the graph of \" + g.getClass().getSimpleName() + \" : \"); sb.append(g.V()).append(\" vertices, \").append(g.E()).append(\" edges \\n\"); int V = g.V(); int[][] matrix = new int[V][V]; for (int v = 0; v &lt; V; v++) &#123; for (Integer w : g.adj(v)) &#123; matrix[v][w] = 1; &#125; &#125; sb.append(\" \"); for (int i = 0; i &lt; V; i++) &#123; sb.append(i).append(\" \"); &#125; sb.append(\"\\n\"); // row i for (int i = 0; i &lt; V; i++) &#123; sb.append(i).append(\": \"); for (int j = 0; j &lt; V; j++) &#123; sb.append(matrix[i][j]).append(\" \"); &#125; sb.append(\"\\n\"); &#125; return sb.toString(); &#125; // 判定插入边v-&gt;w后是否依旧是简单图，true-&gt;is simple public static boolean checkSimpleGraph(Graph graph, int v, int w) &#123; for (Integer i : graph.adj(v)) &#123; // 自环或平行边 if (v == w || i.equals(w)) return false; &#125; //throw new RuntimeException(\"edge has exited: \" + v + \" -&gt; \" + w); //可以选择抛异常或者缄默，这里选择缄默 return true; &#125; // 这是一个选择缄默的简单图判定，大致和上面的一致 public static boolean checkSimpleGraph(Graph graph, int v, int w, boolean throwE) &#123; for (Integer i : graph.adj(v)) &#123; // 自环或平行边 if (v == w || i.equals(w)) return false; &#125; if (throwE) &#123; throw new RuntimeException(\"edge has exited: \" + v + \" -&gt; \" + w); &#125; return true; &#125; // 独立判定平行边 public static boolean hasParallel(Graph graph, int v, int w) &#123; for (Integer i : graph.adj(v)) &#123; if (i.equals(w)) return true; &#125; return false; &#125; // 独立判定自环 public static boolean isLoop(Graph graph, int v, int w) &#123; return v == w; &#125; &#125;&#125; 接下来是ListGraph的完整源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.*;public class ListGraph implements Graph &#123; private final int V; private int E; private final List&lt;List&lt;Integer&gt;&gt; adj; // 这里没有采用我自己写的链表而是JDK的集合类，减轻阅读负担 public ListGraph(int v) &#123; if (v &lt; 0) &#123; throw new IllegalArgumentException(\"Number of vertices must be nonnegative\"); &#125; else &#123; // 初始化计数器 this.V = v; this.E = 0; // 初始化邻接表，顺序存储+链式存储 this.adj = new ArrayList&lt;&gt;(v); for (int i = 0; i &lt; v; i++) &#123; this.adj.add(i, new LinkedList&lt;&gt;()); // 其实你用Vector也是没有任何问题的 &#125; &#125; &#125; @Override public int V() &#123; return this.V; &#125; @Override public int E() &#123; return this.E; &#125; // 新增一条边 @Override public void addEdge(int v, int w) &#123; // 越界检查 GraphUtils.validateVertex(v, this.V); GraphUtils.validateVertex(w, this.V); // 简单图拒绝自环和平行边 if (GraphUtils.checkSimpleGraph(this, v, w)) &#123; this.adj.get(v).add(w); this.adj.get(w).add(v); this.E++; &#125; &#125; @Override public Iterable&lt;Integer&gt; adj(int v) &#123; return this.adj.get(v); &#125; @Override public String toString() &#123; return GraphUtils.printAdjacencyList(this); &#125;&#125; 这里简单解释一下这个类，整体上是“数组+链表”的标准邻接表结构，一开始是用我自己写的背包结构（其实就是单链表）实现的，但是我知道读博客的都不太喜欢看本篇幅之外的过多内容，所以干脆用了集合框架，但其实实际应用时我也是支持用集合框架的，因为你自己写的链表，可能会有bug，性能还没人家集合框架好。。。。 整个代码中最核心的部分就是adj()方法了，这个方法返回一个可迭代对象，可以说是所有图论结构的核心了，我们这里用的集合框架，所以一行就搞定了，但其实如果自己写可以更加细腻（参见十字链表的代码） 测试用例1： 1234567891011121314151617181920212223242526public class TestGraph &#123; public static void main(String[] args) &#123; Graph g = new ListGraph(5); g.addEdge(0, 1); g.addEdge(1, 2); g.addEdge(0, 4); g.addEdge(1, 4); g.addEdge(1, 3); g.addEdge(4, 3); g.addEdge(3, 2); g.addEdge(3, 2); // 陷阱1，平行边 g.addEdge(3, 3); // 陷阱2，自环 System.out.println(g.toString()); // 输出 // the graph of ListGraph : 5 vertices, 7 edges // [0]-&gt;1-&gt;4 // [1]-&gt;0-&gt;2-&gt;4-&gt;3 // [2]-&gt;1-&gt;3 // [3]-&gt;1-&gt;4-&gt;2 // [4]-&gt;0-&gt;1-&gt;3 &#125;&#125; 其实就是上文的演例之一： 测试用例2： 这里贴上一部分Graphs工具类代码，可以清晰看到，简单的邻接结构是多么给力： 1234567891011121314151617181920212223242526// 操作图的工具类，类似集合框架的Arrays类public abstract class Graphs &#123; // 计算某个顶点的度 public static int degree(Graph graph, int v) &#123; int degree = 0; for (int i : graph.adj(v)) &#123; degree++; &#125; return degree; &#125; // 计算最大的度 public static int maxDegree(Graph graph) &#123; int max = 0; for (int i = 0; i &lt; graph.V(); i++) &#123; int de = degree(graph, i); if (de &gt; max) &#123; max = de; &#125; &#125; return max; &#125;&#125; 到此就是无向图的邻接表演示，更多的代码请阅读GitHub（写得比较匆忙，看到问题记得issue） 一点碎碎念 关于存储结构的抉择 图是数据结构中最复杂最灵活也是最重要的一类结构，使用场景成千上万，存储结构极其多变（如果你看了十字链表的实现，想必你深有体会），不同情况下选择不同的数据结构会对程序效率造成极大影响 在为图选择存储结构时，通常有以下考虑： 稀疏或者稠密 读频繁还是写频繁 业务模型适合图吗 这个结构是否会被很多程序引用 举个例子，如果程序仅仅是实现一个简单的状态转移，那么邻接矩阵是一个很不错的选择，你甚至不需要封装图结构，直接一个二维数组+几个操作函数就可以用了，但是V个顶点的图采用邻接矩阵会有O(V**2)的空间损耗，如果是一个地图应用， 那么会有几百万个顶点，这对于空间消耗来说是难以接受的，所以多数情况下使用的是邻接表，在更要求性能的情况下也会升级成十字链表和邻接多重表，但是这两个都是比较复杂的高级数据结构了，写起来比较麻烦，所以比较中庸的做法是邻接表或者邻接集 当然了，所以的片面之词，都不及在你实际的业务中，自己尝试，采用最适合业务的结构 如何使用图结构 其实在实际业务中，很难看见正儿八经像集合框架一样封装的图结构，基本都是想到就用，直接二维数据+操作函数就上，或者数组+线表直接实现了邻接表就上的例子多得是，主要还是图论太过灵活了，很少可以看到一个图结构在多个场景中重复使用的，基本上是A场景来个AOE网，B厂家来个自动机，很少会出现抽象封装的Graph类（本文是为了方便组织各个存储实现代码，业务上是不会有的） 但是设计图结构的宗旨是不变的： 图的表示和存储分离 设计尽可能少和简单的API 通常来说，你会遇到图论的地方只有两个： 笔试题 业务核心 在第一种情况中，通常是类似Leetcode或者ACM一类的的在线编程平台，如下所示： 通常没有什么机会让你把一套代码拆分成多个文件，而且编程时间有限，我们通常会把图论的代码收缩成一套特别简单的demo，然后背一背，遇到这种题目，也别考虑什么封装性了，直接数组+链表写一个邻接表就行了，别整太多花里胡哨的，而第二种情况，当你遇到很复杂的业务逻辑，需要设计一个图结构时，也是简单至上，因为图的API已经很复杂了，再往你的业务里一杵，复杂度能累死你，而且图结构的适应性比较差，一般就是一个问题场景设计一个专用图，换个场景再设计一个，很少会有“万金油”的一类抽象图 总结 图的存储是图论的基础，多看源码，多拍砖，看到有错记得issue 参考 wiki-图论 Algorithms, 4th Edition","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论专栏","slug":"算法/数据结构/图论专栏","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E8%AE%BA%E4%B8%93%E6%A0%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"初识图论-概念和模型","slug":"algorithm/data-structure/graph-theory/graph-theory-first-learn-and-concepts","date":"2020-08-16T14:10:05.000Z","updated":"2021-07-22T01:19:58.362Z","comments":true,"path":"2020/08/16/algorithm/data-structure/graph-theory/graph-theory-first-learn-and-concepts/","link":"","permalink":"http://yoursite.com/2020/08/16/algorithm/data-structure/graph-theory/graph-theory-first-learn-and-concepts/","excerpt":"图结构的基本概念，定理和问题 图结构是计算机中最重要最复杂的一类数据结构 本篇重点讲解图论的基本概念，建立起对图结构的直观看法","text":"图结构的基本概念，定理和问题 图结构是计算机中最重要最复杂的一类数据结构 本篇重点讲解图论的基本概念，建立起对图结构的直观看法 阅读之前 本文是系列文章的其中一篇，关于前后文请参见图论专栏-导读 什么是图 在很多计算机应用里，由相连的结点所表示的模型起到了关键的作用，这一类模型通常由多对多关系组成，其背后的抽象结构就是图。图结构是一种非常重要的数据模型，往往直接和现实世界的问题模型相关联，图论算法是数据结构算法中的精粹，是解决许多重要的实际问题的基础 图论最初被人关注的问题很简单，当我们将个体抽象成一个个相连接的结点后，自然而然产出了一系列问题：通过这些连接能否从一个结点到达另一个结点？有多少结点和指定结点相连？两个结点中最短的连接是哪一条？ 有意思的是，这些看似非常简单的问题恰恰构成了图论算法的核心，当我们深入学习图论算法后，会发现这些算法其实都很简洁，且结构性很强，图论算法的代码通常很短但是很有意思 下表给出了图结构的一些典型应用： 应用 描述 结点 连接 地图 公路网是典型的图，最出名的就是最短路径算法 交叉路口 公路 网络内容 各个网站之间的超链接指向形成了一张图 网页 超链接 电路 电路的元器件连通走向 元器件 导线 任务调度 内核的CPU任务往往有前驱性，可以形成前驱图 任务 限制条件 商业交易 在信息化交易体系中，图可以表示各个产品的资金流向，帮助投资人理清关系 客户 交易 配对 学生可以申请加入机构 学生 申请 计算机网络 类似公路问题，网络算法总是希望找到最快的路径来传递报文 网站 物理连接 软件 最著名的问题恐怕是循环依赖了，利用的就是图的环路问题 方法 调用关系 社交网络 朋友网络是一种图，大型公司通常是用这个图来进行好友推荐 人 友谊关系 认识图论：从一个想过河的人说起 前文说过，很多现实问题，都可以抽象成有关的数学集合和二元关系问题，这里我举一个经典的“人狗羊菜问题”（又称过河问题）为例，就是说一个人带着一只狗，一只羊和一捆菜准备过河，但是河上只有一只小船，承重有限，人每次过河只能带一样东西，但是： 不能把狗和羊同时单独留在一边（狗会吃掉羊） 不能把羊和菜同时单独留在一边（羊会吃掉菜） 问：找到一个策略，将人狗羊菜都带到河的另一边且不损失任何物件？ 在这个问题中，我们拥有4个实体对象，也就是人，狗，羊和菜，我们建立一个二元集合(X,Y)，也就是对于(人狗羊菜,0)表示人狗羊菜都在岸的一边，有人看着相安无事，这一个称为“合法局面”，而另一边是空的，如果是(人狗,羊菜)则表示一边是人狗，另一边是羊和菜，羊吃掉了菜，方案失败，这个称为“非法局面”，除此之外的合法局面还有(0,人狗羊菜)，(人羊,狗菜)，(菜,人狗羊)等等，如果两个合法局面之间可以直接转换，那我们就画一条边，表示它们有直接关系R，由于R是对称的（A-&gt;B等价于B-&gt;A），所以使用直线连接而不是箭头，于是获得下图： 本题这个图又叫“局面转移图”，或者“状态转移图” 观察这个图形，不难发现，图的左右两端是我们问题的起点和终点，只要沿着左端，按照沿路结点的顺序来运送物件，就可以成功运送物件到河岸且无损失（也就是从图的左端点，到图的右端点）。同时观测到这个方案其实有两个，选择哪个都可以解决这个“人狗羊菜”问题 至此我们利用图论解决了第一个问题，想必对图论也有了一个较为直观的感受，其实不难看出，应用图论模型来解决问题其实有一定的步骤： 建立顶点集：根据问题，建立合适的顶点集，顶点往往代表一个状态或者实体 建立边集：在顶点集的基础上，根据条件限制，确认边集（顶点之间的关系，边是关系的具象化） 建立有效模型：在顶点集和边集的模型基础上，并尝试讨论该图是否一些具体性质，如连通性（A点和B点是否有可达通路），优化路径（A点到B点有多条路时是否有一条路比其它路短） 输出有效数据：根据图论拥有或者可能拥有的性质，建立算法步骤，获得解决问题需要的具体数据，如A点和B点若连通，输出其具体的沿途路径，若有可能多条路径，输出路径数目 值得注意的是，实际应用中，图论问题往往是某个复杂问题的子问题（如正则的FSM最后其实就是图的顶点可达性问题），步骤可能不完全一致，但是要点都是一致的 在上文的人羊狗菜问题中，我们也可以看到，一个图形，可能拥有众多特性，如短视性（每个顶点只能和直接相连的顶点移动），选择性（可用方案往往有多个）和对称性（A可到B，则B可到A），讨论这些性质的有无是一个图的重要内容，也是下节的重点 图的重要概念 图结构在应用时种类繁多，尤其灵活，仅凭上节的粗糙模型是无法完整描述并解决图论问题的，必须使用正确严谨的逻辑语言对其进行描述。图的概念众多，基本概念主要分为3类： 点边模型 路径和连通性 子图 图论原本是数学分支，详细之处还请参考严谨离散数学教材，我这里仅作数据结构方面的解释 图的集合定义 设一个图为G，由顶点集V和边集E组成，记为G=(V,E)，其中V(G)表示图G中顶点的非空有限集，E(G)表示图G中顶点之间的关系（边）集合，每个关系（边）都是一个有效的顶点对。对于一个图G，若V={v1,v2,v3 ...}，其顶点数目为图G的阶，记作|V|，且有E={(u,v)|u∈V,v∈V}，记作|E|为该图的边数 线性表和二叉树都可以为空，但是图不可以为空（此处指顶点集必须非空，因为顶点代表实体，但是边集可以非空，也可以空，此时图只有结点没有边） 图的有向性 前文提到，边是图中顶点的一个二元关系，在形式上表示为一个二元关系{v,w}，其中v和w是否表达先后关系决定图是否有向 当图G为有向图时，边为有向边（或者弧），有向边是顶点的有序对，记为&lt;v,w&gt;，作图为箭头，且&lt;v,w&gt;≠&lt;w,v&gt;。对于&lt;v,w&gt;，其中v和w是顶点，其中v称为弧尾，w称弧头，&lt;v,w&gt;称从顶点v到顶点w的弧，其表示v-&gt;w的一条有向边，表达上称v邻接到w或者w邻接自v 设有向图G1=(V1,E2)表示有V1={1,2,3}和E1={&lt;1,2&gt;,&lt;2,1&gt;,&lt;2,3&gt;}，则有作图： 当图G为无向图时，边为无向边（简称边），无向边是顶点的无序对，记为(v,w)，作图为直线，且(v,w)=(w,v)。对于(v,w)，其表示等价于(w,v)，其中v和w是顶点，其中v和w称互为邻接，边(v,w)依附于顶点v和w，其表示v&lt;-&gt;w的一条无向边 设无向图G2=(V2,E2)表示有V2={1,2,3,4}和E2={(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)}，则有作图： 图的有向性其实表示了顶点之间关系的一些限制，比如当你表示地铁站的布局图时，闸机就是一个单向通行的路径，形式上是有向图路径，其通行是单向的，表示家族谱系时同样，每个人只有一个父亲。在数据结构的表示上，其实单链表是一个有向图，每个结点只有一个后驱指针，其只能指向一个后驱结点，并被一个前驱结点指向，双向链表则是一个无向图，既有后驱指针也有前驱指针，每对相邻结点都是互相指向的，所以从结构上来看，无向图其实是一个特殊的有向图（每两个连通的结点都有两条弧，一来一去），但是在实际讨论时，我们还是分开来的，可以避免一些细节问题，但是在本质上我们要明白，其实它们区别不大，甚至相当多算法的无向图版本和有向图版本，代码都可能长一样 简单图和完全图 当图G满足： 不存在重复边 不存在顶点到自身的边 则称该图为简单图，非简单图称多重图。数据结构中不加说明，默认只讨论简单图 简单图有形式简洁性，当我们讨论苏州是否可以到南京时，你有1条路还是20条路关我p事，然后你告诉我还有条路能出了苏州城绕城门一圈回到苏州？？？ 当无向图满足，任意两个顶点之间都存在边时，称无向完全图（完全图又称简单完全图，简单性是完全性的前置条件），含有n个顶点的无向完全图有0.5*(n-1)*n条边。当有向图满足，任意两个顶点之间都存在方向相反的两条弧时，称有向完全图，含有n个顶点的有向完全图有(n-1)*n条弧 一个无向完全图和一个有向非完全图： 顶点的度和边权 度是衡量图中顶点交流性的指标（顶点相连的边越多，交流性越强）。对于无向图来说，某顶点的度其实就是其拥有的边的数目，记作TD(v)，假设某无向图有n个顶点和e条边，有∑TD(v)=2*e，也就是无向图所有顶点的度之和等于边数的2倍。对于有向图来说，某顶点的度分为出度OD(v)和入度ID(v)，假设某有向图有n个顶点和e条边，有∑ID(v)=∑OD(v)=e，也就是无向图所有顶点的出度之和等于入读之和，数值为边数 一般来说，当图G满足|E|&lt;|V|*log(|V|)时，称稀疏图（也就是点多边少），反之称稠密图（点少边多），这在算法选型时很重要，因为部分算法在稀疏图上性能好，另一些在稠密图上性能好 在一些图中，边可以拥有一个具有某种意义的数值，该数值称该边的权值，该边称带权边，这个图称为带权图，又称网。通常来说，边的权代表了通过这条边所需要的“代价” 路径和连通性 在直观上，图就是一堆互相连接的点，用来表示某个现实模型，我把之前“人狗羊菜”的图改动了一下： 顶点v1到顶点vn的一条路径（或者通路）是指顶点的可通过序列[v1,v2…vn]，路径上边的数量称路径长度。顶点之间的最短路径长度称距离。当路径的起点和重点重叠时，称该路径为回路或环（形态上会形成一个圈，上图的{3,4,5,6,7,8}就是一个回路） 环路判定定理：若一个图有n个顶点且边数&gt;n-1，则该图必存在回路 在“人羊狗菜”问题中，我们把原本过河的逻辑问题，转换成了顶点1到顶点10的可达性问题，像这种在无向图中，如果顶点v到顶点w有路径存在，则称v和w是连通的，在本例中顶点1到顶点10拥有两条路径。如果图G中任意两个顶点是连通的，则称图G是连通图，反之为非连通图。我们的“人狗羊菜”的就是一张连通图，也就是所有的点都连在了一个主体里，但是有时候会出现这样一种情况，有一个点“脱离”了图的主体，成为了一个不和任何点连通的“孤独”的顶点，这就称作孤点，下图中的顶点6就是一个孤点： 孤点存在定理：若一个图有n个顶点且边数&lt;n-1，则该图必是非连通图（换言之，存在孤点） 注意，连通性是无向图的概念，有向图有个类似的性质，叫做强连通性，在有向图中，如果从顶点v到顶点w和从顶点w到顶点v都存在路径，那么称这两个点是强连通的，任意两个结点都强连通的有向图称强连通图 图的连通性和强连通性是一个图论核心性质，从数学结构上来说，连通性和强连通性都是一种等价关系，从直观上来说就是所有顶点之间都“有来有回”，从算法上讲，拥有连通性/强连通性的图，掌握了其中一个顶点，就可以掌握其中所有的顶点，就拿有向图来说，强连通性确保“数据的循环流动”，举个例子，有个金融分析师要研究最近十年的市场资金流动，他分析了12家公司的财务报表： 发现这根本不是一个强连通图，也就是说资金无法像生态循环一样在市场持续流动，而是最终进了4公司，10公司和12公司，这就不是一个健康的市场流动，而那这几家公司就很有可能是洗钱大户或者垄断联盟。这种问题很常见，同样的问题也可能发生在旅游过程中，很多景点之间只有单向车次，所以如果交通布局不是强连通的，很可能就出现你坐车去，结果玩了几个景点，最后要走路回来，可以说，连通性和强连通性保证了图的“连通健康” 值得注意的是，和简单图一样，我们讨论的所有路径和回路，都是简单路径（路径中顶点不重复出现）和简单回路（除顶点自叠外，无重复顶点） 子图和连通分量 设有两个图G=(V,E)和G'=(V',E')，若V'是V的子集且E'是E的子集，则称G'是G的子图。如果G'是G的子图，且V(G')=V(G)，则称G'是G的生成子图（只删边，不删点） 子图是一个图的重要概念，回到之前提到的连通性问题，不是所有图都是连通图，观察下面的无向图G： 使用我们上文的连通性定义，可以清晰看到这个无向图中有3个“孤岛”，也就是{1,2,3,4,5}，{6,7,8}和{9,10}，在它们各自内部保证了连通性，成为了一个独立于整体的小“连通图”，像这一类无向图中的极大连通子图称为连通分量。本例的无向图拥有3个连通分量： 值得注意的是，极大联通子图在是G的子图的同时，要包含该“孤岛”内尽可能多的边，不然只能是连通子图，而不是极大连通子图。同样的概念还有极小联通子图，在保证子图连通性的同时，包含尽可能少的边 子图在图论中有很重要的应用，尤其是生成子图和生成树，再处理复杂图时，是一个很重要的简化和分析工具，就比如你遇到这么样一个迷宫问题： 其实你很难一次性看出这个迷宫是不是整体相连的（连通图），有可能出现几条路是自闭的，不和主路相连，提前采取连通性分析可以少走弯路，如果发现自己的起点就是在一个不包括出口的自闭路径里（连通分量），那就直接放弃就行了，免得无用功 既然无向图有连通分量，那自然同样的概念也发生在有向图中，有向图G的极大强连通子图称为该有向图的强连通分量。定义类似不多赘述 树和图的关系 本节默认你对树有所了解，知道树的基本概念和形态即可 首先来看一下数据结构的分级： 一对一关系：线性表（背包，栈和队列） 一对多关系：树（一般树和二叉树） 多对多关系：图（有向图和无向图） 从形态上讲，树其实是一种特殊的图，这里给出了5个顶点的2种边集组合，分别构成了树A和图B： 可以从形态上清晰看到，我们的树A其实就是图B的一个生成子图（只删边不删点的子图，见上文定义），生成子图是一个很常用的工具，它在保证连通图的顶点完整性和连通性的同时，不断删除多余的边，来减少边集冗余，当边数删到极限了，图就退化成一棵树，这棵树就称为连通图的生成树，它是包含图中全部顶点的一个极小连通子图 若连通图的顶点数为n，则它的生成树含有n-1条边，且对生成树而言： 删去一条边，它就会变成非连通图 加上一条边，则会形成环路 在非连通图中，各连通分量的生成树构成了非连通图的生成森林： 一个顶点的入度为0，其余顶点的入度均为1的有向图，称为有向树。同样是5个顶点，下图构造了一棵有向树和一个有向图： 可以看到上图的有向树其实是有向图的一个生成子图 我们通常只在无向图中讨论生成树，有向树和生成树定义类似，但不是同一个感念（不是有向图的生成树），不要混淆 生成树和生成子图问题是很常见的一类图论问题，其核心在于“保证顶点集的完整性同时，减少边的数目”，经常用于一些需要“压缩时间和空间成本”的场合。举个例子，苏州市要修地铁了，但是地铁造价昂贵，市政府希望规划的几条线路能覆盖尽可能多的重要交通点（比如苏州火车站，观前街和市立医院），保证这些地点连通的同时，减少需要修建的地铁线，这个时候，设计师会将所有的比如30个站点先在地图上画出来，构造一个无向完全图，然后针对地区造价和施工难度，不断删除多余的边，最后获得一个接近生成树的生成子图结构，保证了地区连通性的同时，减少了建造成本。苏州市轨道交通布局图： 图的数学表示法 矩阵表示法是图论的数学表示，之前我们看见的都是图例，属于图形表示法，优点是直观，但是没有数学结构，无法被计算机理解，矩阵表示法就是可以表示一个图的最早的可用数学模型 这里先给出有向图A和无向图B的图例（图形表示法）： 对于有向图A：V={0,1,2,3}且E={e1=&lt;0,1&gt;,e2=&lt;0,2&gt;,e3=&lt;2,0&gt;,e4=&lt;2,3&gt;,e5=&lt;3,0&gt;,e6=&lt;3,1&gt;,e7=&lt;3,2&gt;} 对于有向图B：V={0,1,2,3,4}且E={e1=(0,1),e2=(0,4),e3=(1,2),e4=(1,3),e5=(1,4),e6=(2,3),e7=(3,4)} 关联矩阵法 对于一个图G=(V,E)，构造一个n*m的矩阵M，使得： |V|=n |E|=m M(i,j)=1，表示顶点vi和边ej有关联 M(i,j)=0，表示顶点vi和边ej没有关联 那么称这个n行m列的矩阵M为图G=(V,E)的关联矩阵。上文图例中有向图和无向图的关联矩阵表示： 可以看到关联矩阵表示法其实蛮蛋疼的，有大量的数据空白，对于计算机来说利用率很低 邻接矩阵法 对于一个图G=(V,E)，构造一个n*n的矩阵M，使得： |V|=n M(i,j)=1，表示顶点vi和vj有邻接 M(i,j)=0，表示顶点vi和vj没有邻接 那么称这个n行n列的矩阵M为图G=(V,E)的邻接矩阵。上文图例中有向图和无向图的邻接矩阵表示： 邻接矩阵很适合计算机存储，是常用方案之一 矩阵压缩 观察邻接矩阵法所表示的无向图，其实会发现它是沿方阵对角线对称的，所以在实际操作时，可以只存储它的上三角阵或者下三角阵，必要时可以将其压缩成一个一维向量，在之后讲图论存储结构的博文里会有描述，本篇不作详解 几个特殊的图和图论的主要问题 文章一开始就提过，图结构往往反应的是现实问题，所以图的种类千变万化，除了本文列举的几个基本概念外，有很多特殊图，都是针对不同问题出现的特殊结构，篇幅有限不作详解，仅仅罗列一下常见的，之后讲解相关问题的博文里会专门补充，这里混个眼熟即可： 欧拉图 哈密尔顿图 正则图 二分图 详细内容现已并入我的图论专栏 总结 本篇作为入门篇，主要介绍了图论作为数据结构的主要概念，大部分都是概念的描述，详细定义并分别这些概念，是学习图论的重要步骤（免得以后题目都看不懂），这其中的概念主要有3个： 点边模型：了解图结构在数学上的集合本质，了解顶点集和边集是图的必要组成部分，并判断图的有向性，建立度和权的概念 路径和连通性：连通性是图的最核心特征，连通的图在算法上才有意义，路径问题是图论算法的一个大块 子图：图通常是一个拥有数百万结点的大型结构，子图可以很好的简化复杂图，树图转换也是一个很重要的图论算法 本篇提及的概念都很基础，是必须掌握的，尤其是几个判定定理，在之后的算法中，通常会起到关键作用（如环路判定定理在循环依赖检查算法中非常有用）。希望我提的例子能帮你开始理解图这种结构，建立起良好的直观，篇幅较长，写作匆忙，勘误还请issue或者直接评论指出 参考 wiki-图论 Algorithms, 4th Edition 离散数学 数据结构","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论专栏","slug":"算法/数据结构/图论专栏","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E8%AE%BA%E4%B8%93%E6%A0%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"图论专栏-导读","slug":"algorithm/data-structure/graph-theory/graph-theory-guide","date":"2020-08-15T14:43:37.000Z","updated":"2021-07-22T01:19:58.363Z","comments":true,"path":"2020/08/15/algorithm/data-structure/graph-theory/graph-theory-guide/","link":"","permalink":"http://yoursite.com/2020/08/15/algorithm/data-structure/graph-theory/graph-theory-guide/","excerpt":"图论专栏导读-如何阅读本系列博客 图论专栏系列文章的导读和目录 关于专栏 图论算法是一个重要的算法领域，其参与构成了几乎所有计算机领域的算法基础，图论作为数学和计算机分支前后发展了近300年，整个领域的研究至今依旧活跃。我把写的一系列图论的相关理解和算法笔记编辑成博客，收录成了一个专栏，本文是这些文章的导读，同时也是总索引，希望我的这些文章可以帮助你一窥图论的真实秘密","text":"图论专栏导读-如何阅读本系列博客 图论专栏系列文章的导读和目录 关于专栏 图论算法是一个重要的算法领域，其参与构成了几乎所有计算机领域的算法基础，图论作为数学和计算机分支前后发展了近300年，整个领域的研究至今依旧活跃。我把写的一系列图论的相关理解和算法笔记编辑成博客，收录成了一个专栏，本文是这些文章的导读，同时也是总索引，希望我的这些文章可以帮助你一窥图论的真实秘密 阅读之前 本专栏默认你已经有了数据结构和组合数学的一些基础，懂得单链表在内的基本数据结构，懂得辨识树的各个结构和性质，最好懂一些集合论和二元关系，如果想看相关的理论基础篇，也可以issue或者评论，我会把这些知识编辑成番外篇补充在文后 专栏内的文章最早是我的上课笔记和辅导学弟学妹的讲义，现编辑成博文，每篇文章都可以单独阅读，但是其中的储备知识是前驱的，建议从图的概念开始顺序阅读，博文中出现的代码均收录在graph-algorithm-kit 阅读之后 这里列出了我认为的一个程序员读完本系列后必须掌握的硬知识： 图的基本概念（点边模型，连通性问题，子图概念和树图转换） 图的4种存储（矩阵，表，十字链表和多重表）和基本操作（封装和核心API） 图的2个核心搜索（BFS和DFS） 图的4个重点应用问题（最小生成树，最短路径，拓扑排序，关键路径） 以及一些我认为比较重要的软实力： 对实际问题进行建模 针对问题场景修改存储结构 将复杂的图论问题转换成已知问题的解 分辨不可解问题（有些问题在图论上属于无定论） 图的概念和基本性质 基础篇必读 初识图论-概念和模型 二部图的概念 欧拉图和一笔画问题 哈密尔顿图的概念 图的存储模型 要想使用图，必须先将图从纯粹数学模型，转换为计算机可以理解和存储的代码结构 记住图的设计重点就是把图的表示和实现分离开来，良好的封装是代码可读性的保障 图的存储结构及封装 AOE和AOV 5个基本问题和8个核心算法 1. 图的搜索和连通性问题 深度优先搜索和广度优先搜索 连通性问题 2. 最短路径问题 Dijkstra算法 Floyd-Warshall算法 3. 最小生成树问题 Prim算法 Kruskal算法 4. 拓扑排序问题 TSA 5. 关键路径问题 CPA 图论算法进阶 欧拉图，哈密尔顿图和二部图 填色问题和四色原理 网络流问题 强连通性问题 子图覆盖问题 同构问题 自动机 图论题集 割点问题","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论专栏","slug":"算法/数据结构/图论专栏","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E8%AE%BA%E4%B8%93%E6%A0%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"手工实现Java热加载","slug":"java/hotswap/java-hot-swap-mechanism","date":"2020-08-15T08:39:00.000Z","updated":"2021-07-22T01:19:58.370Z","comments":true,"path":"2020/08/15/java/hotswap/java-hot-swap-mechanism/","link":"","permalink":"http://yoursite.com/2020/08/15/java/hotswap/java-hot-swap-mechanism/","excerpt":"","text":"施工中…","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"缓存置换算法和LRU实现","slug":"algorithm/classical/classical-algotithm-for-cache-replacement","date":"2020-08-14T07:33:30.000Z","updated":"2021-07-22T01:19:58.361Z","comments":true,"path":"2020/08/14/algorithm/classical/classical-algotithm-for-cache-replacement/","link":"","permalink":"http://yoursite.com/2020/08/14/algorithm/classical/classical-algotithm-for-cache-replacement/","excerpt":"缓存置换的常见策略和LRU算法实现 常见于缓存池更新方面的应用 内核设计的页面置换机制中有重要应用","text":"缓存置换的常见策略和LRU算法实现 常见于缓存池更新方面的应用 内核设计的页面置换机制中有重要应用 开篇 就算不是学计算机的，也会对缓存技术有所耳闻，包括“浏览器缓存”和“手机缓存垃圾”在内的各种名词，其实早就给你塑造了一个缓存的大概形象，本篇不会纠结缓存的定义到底是什么，主要是介绍缓存技术在计算机内存和程序设计方面的实现和一些常见案例，建立起对缓存技术的一个比较清晰的概念 早期CPU的困境 缓存，英文Cache，最早出现于1967年的一篇电子设计论文，Cache原本是一个法语词，在论文中被作者用来指意safekeeping storage。在以前16位机的时代，CPU和内存都很慢，不存在什么Cache技术，运行指令时由CPU直接访问内存，到了80386的32位机时代，出现了Cache技术，众所周知，在现代计算机体系结构中，存储是拥有级别的，最快的存储单元是CPU的寄存器，同时也最昂贵，通常只负责存储会参与直接计算的数据和指令，其次是内存，内存比CPU寄存器慢，但是造价相对便宜，进入21世纪后，随着内存技术的升级，8GB的DDR4内存条也只要几百块就能买到了（而一颗拥有若干KB存储的Intel处理器就大几千了），最便宜的则是外部存储设备了，也就是常见的硬盘技术，大容量，造价便宜，但是数据读写也最慢。由此可知，在Cache技术出现之前，CPU里的寄存器虽然很快，但是程序的指令是加载在内存里的，CPU要执行指令，就要到内存中去读取一条条的指令，就算你寄存器计算时再快，但是内存的IO瓶颈在那里，CPU在等待内存返回指令之前就只等“干着急”，所以计算机的运行速度一直上不去 救世主的到来：Cache技术 但是随着80386系列的处理器的出现，情况就不同了，80386的芯片组增加了对可选的Cache的支持，高级主板可以携带64KB。提供“缓存”的目的是为了让数据访问的速度适应CPU的处理速度，上文提过了，在Cache技术出现之前，CPU直接访问内存，内存如果慢了，CPU再快也要等内存，而出现了Cache之后，当CPU处理数据时，它会先到Cache中去寻找，如果数据因之前的操作已经读取而被暂存其中，那就直接读取Cache中的指令结果，这样一来，CPU再也不用每次都等“慢吞吞”的内存了，整体的计算效率也上去了 Cache技术能够成功的原理之一，就是所谓的“程序执行的局域性原理”，用人话讲就是“一定程序执行时间和空间内，被访问的代码集中于一部分”，除了C语言之外，包括Java在内的很多编程语言都会使用Cache机制提高自己的执行速度，有兴趣的可以了解一下Java的voliate关键字 下图是Intel Core i5-4285U的CPU三级缓存示意图（随便看看就行了，本篇不是讲CPU的）： 广义缓存技术 而在现在，缓存技术不再仅仅是指CPU的Cache了，而是在各类计算机问题中都找到了应用，我们称之为广义缓存技术（其实我们现在在大部分情况下提到的都是广义的缓存技术），根据我们上文了解到的Cache技术的历史，可以了解到所谓的Cache其实有3个基本属性： 热数据 根据“局部性原理”，系统目前访问的数据A，极有可能在不久的未来二次访问，所以我们就将这个数据暂存起来，之后再访问的时候就免得再找一次了，直接从缓存中拿，提高了系统的整体速度。当CPU执行其它程序，或者当前热数据已经修改时，再通过一定的机制更新热数据，保证缓冲区存放的是“最要紧的数据” 不对等存储 Cache的出现说到底是CPU的高速存储和内存的低速存储之间的读写速度不对等造成的，这个“不对等”现象其实非常常见，比如Redis作为Mysql的数据缓存，就是因为关系数据库每次读写都是基于磁盘的，非常慢，但是Redis作为键值数据库运行在内存中，大大提高了关系数据库中的“热数据”（比如某个用户的微博访问量）的访问速度，在高并发环境下是非常有效的策略 有限容量 在讲CPU时提到了，不对等存储的出现，本质上还是存储设备的造价问题，所以你在高速设备（容量A）和低速设备（容量B）之间提供的缓存区（容量C）通常会有A&lt;C&lt;B这样的关系，所以这就导致了缓存技术能提供的容量也是有限的，当缓存容量用尽时，就会出现更新策略，也就是本文的重点之一：Cache Replacement Policies缓存置换机制 缓存置换的4个基本策略 让我们继续回到富含激情的80年代，当时能使用的计算机多是16位机，比如经典的8086体系，拥有20位的地址总线，也就是说我们的内存其实只有2^20B=1MB的容量，但是数据文件可没有因为你是早期计算机就变小，假设你在当时的斯坦福大学，要检阅学校服务器上的一个2MB大小的学生信息文件，你怎么办？ 通过上文的阅读，我们知道一个缓存机制的3个特点：热数据，不对等存储和有限容量在我们的这个场景里其实全有了，所以有了以下解决方案，也就是经典的“大文件局部加载方案”（又是一个比我年纪还大的算法）： 将文件分片，2MB的文件分成2048片，每片1KB大小，只有当你的阅读器读到当前的文件片时，才将文件加载进内存，剩下的留在硬盘里 计算机读文件时，会先检索内存中是否已经加载过目标文件片了，如果已加载，则直接从内存中取 如果内存满了，那就按照某些规则，放弃一些“旧的”文件片，给新来的文件片挪位置 这里的某些规则其实就是缓存置换策略，常见策略一共4个： FIFO：First In First Out，最先进入的内容作为替换对象 LRU：Least Recently Used，最久没有访问的内容作为替换对象 LFU：Least Frequently Used，最近最少使用的内容作为替换对象 MRU：Most Recently Used，最近使用的内容作为替换对象 其实策略还有非常多，取得应用的有几十个，这几个时属于比较常见比较常见的 Cache Hit/Miss和缓存命中率 还是上面的大文件分片加载的案例，既然缓存置换策略那么多，那么肯定会出现良莠不齐的情况，那么就需要一个衡量标准，下面接触两个概念： Cache Hit/Miss Cache Hit又称缓存命中，当我们的程序发出了一个文件片的加载指令，我们会查询文件片缓存池中是否有这个文件片，如果有，那就表示Cache Hit了，我们直接从缓存中读取这个文件片，反之如果发现这个文件片不在缓存中，那么就表示Cache Miss，我们需要出发一个I/O读写任务，付出额外的时间代价去硬盘读取目标文件片 缓存命中率 根据Cache Hit/Miss的定义，我们自然是希望Cache Hit的情况多于Miss的情况，Hit越多，说明我们的缓存确实生效了，所以出现了缓存命中率的公式：Hit Rate=(Cache Hit)/(Cache Hit+Cache Miss) 假设我们的缓存区容量为：3个文件片，现在我们的程序发出的读写序列为{7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0,1}，其中的数字代表文件片编号： 现在我们构造了一个空表，可用来理解各个策略在实施时的不同： 请求序号 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1 缓存片0 缓存片1 缓存片2 结果 读取 丢弃 结果一栏是指是否命中，H=Cache Hit &amp;&amp; M=Cache Miss FIFO：先进先出算法 在这个策略中，发生Cache Miss时，会优先丢弃最早进入缓存的文件片，也就是说每次都淘汰当前缓存中在内存中驻留时间最长的那个文件片。在本例中，Hit了5次，Miss了15次，命中率为25% 请求序号 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1 缓存片0 7 7 7 2 2 2 2 4 4 4 0 0 0 0 0 0 0 7 7 7 缓存片1 0 0 0 0 3 3 3 2 2 2 2 2 1 1 1 1 1 0 0 缓存片2 1 1 1 1 0 0 0 3 3 3 3 3 2 2 2 2 2 1 结果 M M M M H M M M M M M H H M M H H M M M 读取 7 0 1 2 3 0 4 2 3 0 1 2 7 0 1 丢弃 7 0 1 2 3 0 4 2 3 0 1 2 LRU：最近久未用算法 发生Cache时，会检索使用记录，保留最近用过的文件片（也就是丢弃最近没用过的文件片），这个其实是局部性原理的反应，程序认为过去一段时间内不曾被访问的页面，在最近的将来也不会被访问，所以它总是丢弃最近一段时间内最久不用的文件片。在本例中，Hit了10次，Miss了10次，命中率为50% 请求序号 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1 缓存片0 7 7 7 2 2 2 2 4 4 4 0 0 0 1 1 1 1 1 1 1 缓存片1 0 0 0 0 0 0 0 0 3 3 3 3 3 3 0 0 0 0 0 缓存片2 1 1 1 3 3 3 2 2 2 2 2 2 2 2 2 7 7 7 结果 M M M M H M H M M H M H H M H H H M H H 读取 7 0 1 2 3 4 2 0 1 7 丢弃 7 1 2 3 4 0 2 这里是为了画表方便，正式编写时，缓存片的存储顺序会稍有不同，下文讲实现时会提及 LFU：最近低频淘汰算法 这个策略有一点点类似LRU，但是这里衡量的并不是文件片最近有没有被使用（时间戳），而是在最近一段时间内，它被访问的次数，访问率低的文件片会被丢弃。在实现上，其实就是给每个文件片加一个计数器，访问了就喜加一，当出现缓存不够时，检索当前缓存中，计数器最小的那个，把它的计数器清零后踢出缓存（好惨）。这个算法其实经常和LRU一起使用，因为如果你发现目前缓存区里所有文件片的计数器都一个大小，那你就要考虑通过LRU来抉择了（如下图的第4次Miss）。在本例中，Hit了9次，Miss了11次，命中率为45% 请求序号 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1 缓存片0 7(1) 7(1) 7(1) 2(1) 2(1) 2(1) 2(1) 4(1) 4(1) 3(1) 3(1) 3(2) 3(2) 1(1) 1(1) 1(1) 1(2) 7(1) 7(1) 1(1) 缓存片1 0(1) 0(1) 0(1) 0(2) 0(2) 0(3) 0(3) 0(3) 0(3) 0(4) 0(4) 0(4) 0(4) 0(4) 0(5) 0(5) 0(5) 0(6) 0(6) 缓存片2 1(1) 1(1) 1(1) 3(1) 3(1) 3(1) 2(1) 2(1) 2(1) 2(1) 2(2) 2(2) 2(3) 2(3) 2(3) 2(3) 2(3) 2(3) 结果 M M M M H M H M M M H H H M H H H M H M 读取 7 0 1 2 3 4 2 3 1 7 1 丢弃 1 2 3 4 3 1 7 如果表太长了导致滚动条，请把浏览器窗口拉长 7(1)表示文件片7的计数器为1 LFU算法有一个小问题，那就是如果某个文件片在载入缓冲区后被大量读写，然后程序就再也不访问了，这种情况下，就会因为之前大量访问给文件片制造了一个超大的计数器，就会变成“仗着祖上阔的恶霸”，导致“赖在缓存区不走”，所以正式使用时，计数器都是有时效的 MRU：最近使用淘汰算法 乍一听蛮奇怪的，当缓存区满时，这个策略会淘汰最近只用过的文件片，这不是给自己添堵？但其实这个在某些场合非常使用，比如你要对某个大型数据集进行循环扫描（又称循环访问模式，由于MRU缓存算法倾向于保留较旧的数据，因此它们比LRU的命中率高，这个算法的图留给观众老爷们自己画吧，当是测试了（其实就是作者偷懒） 缓存置换策略的选择 上面是给出了4种基本的置换策略实现，但是可以看出，这些算法的效率是极度依赖输入队列的，也就是读写序列，在某些情况下，可能LRU命中率高，换个情况可能就是MRU高了，所以类似虚拟内存这种使用了缓存/页面置换算法的场景，其实是准备了多种策略，监控其命中率指标，根据系统任务的表现，可以做到随时切换，我们在设计自己的缓存系统时也可以这么考虑 而且默认环境下，我们一般会采用LRU+LFU的做法，在各种测试中，这一类的组合表现比较稳定 LRU Cache算法的实现 为了加强对算法的理解，我们来实现一下LRU策略的缓存置换算法，LRU的策略可能很简单，但是在各个场景（比如内核）下进行应用时会产生大量的变种，我们这里给出的示例属于“面试特供版”，因为企业在笔试时很喜欢问LRU一类的问题，考察对数据结构的掌握。我们这里只实现LRU，其它策略也基本大同小异，观众老爷可以自行摸索 在实际编写代码之前，我们来回顾一下，LRU的基本策略： 维护一个限制大小的缓存池 当缓存空间满了的时候，将最近最久少使用的数据从缓存空间中删除，以增加可用的缓存空间来缓存新的数据 LRU的核心数据结构 因为我们要定位最久少使用的数据，所以我们需要一个可以记录时间顺序的结构，在这里我们使用增强型的链表，也就是双向链表，现在确定一下我们的算法基本步骤： 设置一个双向链表visited_list模拟循环队列，用来记录数据的新旧（仅记录数据的编号），新数据插入到头部，旧数据从尾部丢弃 设置一个字典dict&lt;数据编号:数据内容&gt;作为真正的数据存储池 读取请求来后，访问字典dict来判定Cache Hit/Miss Cache Hit后，更新visited_list，Hit了的数据编号会被取出，插入到头部，这样确保从尾部丢弃的确实是最久且最少被使用的数据（因为新数据都被更新去头部了，而根据队列的特性，靠近尾部的都是老数据），从dict中返回对应的数据内容 Cache Miss后，查询缓存是否富余，富余则直接向dict和visited_list插入新数据，不足则会删除visited_list的尾部数据，删除dict中对于的数据内容，将新数据调入并插入到visited_list头部和dict 完整的Java代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package com.blade.app.lru;import java.util.HashMap;/** * 维护一个类似双向链表的数据结构，包含前驱后继以及键值结构 */class Node &#123; Node next; Node prev; int key; int val; public Node(int key, int val) &#123; this.key = key; this.val = val; &#125; public Node() &#123; &#125;&#125;class LRUCache &#123; // 散列提供O(1)的读写 HashMap&lt;Integer, Node&gt; map; // 头指针，head-&gt;next指向最近访问的结点 Node head; // 尾指针，head-&gt;prev指向最久访问的结点 Node tail; // 容量 int capacity; // 结点计数 int count; public LRUCache(int capacity) &#123; // 计数 this.capacity = capacity; this.count = 0; map = new HashMap&lt;&gt;(); head = new Node(); tail = new Node(); // 循环队列 head.next = tail; tail.next = head; &#125; public int get(int key) &#123; // 如果 key 在 HashMap 中，先拿到该结点，删除结点，再插入结点。 if (map.containsKey(key)) &#123; Node node = map.get(key); remove(node); insert(node); return map.get(key).val; &#125; // 如果不在就返回 -1 return -1; &#125; public void put(int key, int value) &#123; // 如果 key 在 HashMap 中，和 get 类似，也是先拿到该结点，删除结点，再插入结点。 if (map.containsKey(key)) &#123; Node node = map.get(key); node.val = value; remove(node); insert(node); &#125; else &#123; // 如果 key 不在 HashMap 中，那么是一个新的结点，直接插入即可。 Node node = new Node(key, value); insert(node); &#125; &#125; public void remove(Node node) &#123; if (count &gt; 0) &#123; // 在 map 中移除结点前，先将双向链表的指针指向进行修改 Node prev = node.prev; Node next = node.next; node.prev = null; node.next = null; next.prev = prev; prev.next = next; map.remove(node.key); count--; &#125; &#125; public void insert(Node node) &#123; Node next = head.next; head.next = node; node.next = next; next.prev = node; node.prev = head; map.put(node.key, node); count++; // 如果结点数超过可允许容量，将 least recently 的结点移除 if (count &gt; capacity) &#123; remove(tail.prev); &#125; &#125;&#125;public class TestLRUCache &#123; public static void main(String[] args) &#123; // 容量定为4 LRUCache cache = new LRUCache(4); // 初始化节点 Node[] nodes = new Node[6]; for (int i = 0; i &lt; 6; i++) &#123; nodes[i] = new Node(i, i * 100); &#125; // 定义访问序列 int[] visit_q = &#123;0, 1, 2, 4, 5, 2, 3, 4, 3, 0, 1, 4, 5, 3&#125;; for (int i : visit_q) &#123; Node n = nodes[i]; cache.put(n.key, n.val); &#125; System.out.println(\"end.\"); &#125;&#125; 在本例中，我使用的访问队列为{0, 1, 2, 4, 5, 2, 3, 4, 3, 0, 1, 4, 5, 3}，老规矩可以画出下面的过程图： 请求序号 0 1 2 4 5 2 3 4 3 0 1 4 5 3 结点0 0 1 2 4 5 2 3 4 3 0 1 4 5 3 结点1 0 1 2 4 5 2 3 4 3 0 1 4 5 结点2 0 1 2 4 5 2 2 4 3 0 1 4 结点3 0 1 1 4 5 5 2 4 3 0 1 结果 M M M M M H M H H M M H M M 这个图和之前的不太一样，因为这里的结点0-3时有顺序的，每次更新的数据都会被提到结点0的位置，而每次也都是从结点3淘汰数据 如果你仔细观察，会发现我们的LRU表有明显的阶梯型 一点碎碎念 到此，“大文件局部加载”的案例就结束了，剩下还有一点碎碎念，有兴趣的朋友可以自己扩展一下： Linux中的虚拟内存概念就是基于页面置换算法（缓存置换的一种实现），通过这种方式，物理内存不再是程序运行的限制，假设你有8GB的物理内存，但是虚拟内存可以达到16GB，溢出的内存直接以交换区的形式放到磁盘上就行，但是时刻注意，置换算法是典型的时间换空间，你的内存虽然扩大了，但是调度是要吃CPU的。这种方式又叫“虚拟扩容” “抖动现象”是指数据频繁进出缓存区，如果针对某个的访问队列使用了不合适的置换算法，就会出现这种情况，命中率下降，消耗了CPU的同时，没有获得缓存的优势 总结 到此为止，关于缓存置换算法就草草讲完了，实现只写了LRU的Java实现，感兴趣的可以去看看Linux内核的源码，里面对置换算法是真的玩出花了，如果感觉不太理解的话，可以自己去看一下wiki或者动手把表画一下。如果你发现了文章错误，记得在评论区指出QAQ","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"经典算法","slug":"算法/经典算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"有序全排列问题","slug":"algorithm/exercise/question-next-permutation","date":"2020-07-15T11:26:45.000Z","updated":"2021-07-22T01:19:58.366Z","comments":true,"path":"2020/07/15/algorithm/exercise/question-next-permutation/","link":"","permalink":"http://yoursite.com/2020/07/15/algorithm/exercise/question-next-permutation/","excerpt":"“下一个全排列”问题 全排列问题和字典序算法的融合问题 帮助理解序理论的重要材料","text":"“下一个全排列”问题 全排列问题和字典序算法的融合问题 帮助理解序理论的重要材料 问题描述 排列问题是组合数学中的基本问题之一，给定数组{1,2,3}，对其中的元素进行重新排列，会有6种不同的序列，分别是{1,2,3}，{1,3,2}，{2,1,3}，{2,3,1}，{3,1,2}和{3,2,1} 将这6个排列按照数字从小到大排个前后，有下表： 序号 排列 1 {1,2,3} 2 {1,3,2} 3 {2,1,3} 4 {2,3,1} 5 {3,1,2} 6 {3,2,1} 仔细观察一下，这其中其实是一种类似英语词典中，单词的排序，也就是a-开头的单词在b-开头单词的前面，ab-开头的单词在am-开头的单词的前面，这种排序法则就是字典序，详细定义如下： 给定两个偏序集A和B，(a,b)和(a′,b′)属于笛卡尔积A×B，则字典序定义为：(a,b)≤(a′,b′)，当且仅当a&lt;a′或(a=a′且b≤b′) 结果是偏序（如果A和B是全序, 那么结果也是全序） 这里的偏序关系是离散数学的序理论中的概念，有些生疏的可以把《离散数学》的书翻出来看看 到这里我们的问题就可以提出来了：从当前排列生成字典序刚好比它大的下一个排列 问题分析 在这里我们先来观察一种现象，我称之为“地板天花板”现象，现在给定{1,2,3,4}四个数字，可以排列出P(4,4)=24个四位数，其中有： 天花板：也就是最大的数字排列4321，也称降序列（从第一个数字到最后一个数字都在减少） 地板：也就是最小的数字序列1234，也称升序列（从第一个数字到最后一个数字都在变大） 观察上面的两个数，可以很容易看出，天花板和地板是正好反过来的，我们这个时候再来看另一个例子，这个例子里，我们使用{1,3,4,5}四个数字，并且固定首位为4，那我们可以得到天花板和地板： 天花板：4531，531是一个3位降序 地板：4135，135是一个3位升序 现在我们的重点来了，我们都知道一层楼的天花板肯定比地板高，就像上面的531比135大一样，我称之为做“同1层的天花板比地板高”原理，在这之外还有一个“5楼的地板比4楼的天花板高”原理。还是上面的两个数字4531和4135，我们把4531看作“4楼的天花板531”，4135看作“4楼的地板135”，如果我们把首位的4换成5，那就有“4楼的地板135”变成“5楼的地板134”，也就是5134，这个5134其实就是4531的“下一个字典序排列” 到此为止，我们的算法流程就算是出来了，有4步： 找到排列中最右侧的一个升序，记录其首地址i（找到这层楼的地板），并记录x=a[i] 找到排列中i右侧最后一个比a[i]大的位置j（找到下上层楼的层数），并记录y=a[j] 交换x和y 将i之后的尾部整个反转 拿21543举个例子： 从右到左找一个升序15，记录x=1 在1右侧找到最后一个比1大的数字，也就是y=3 交换1和3，21543-&gt;23541 反转541，获得23145 自此23145就是21543的下一个“字典序排列” 算法实现 这里给出我们的Java实现，其实C++的STL库里的next_permutation()函数也是类似的思路。这里是完整的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.Arrays;public class GetPermutation &#123; private static int count = 0; private static int[] nums = &#123;0, 1, 2, 3, 4, 5, 6, 7&#125;; private static void swap(int a, int b) &#123; if (a &lt; nums.length &amp;&amp; b &lt; nums.length) &#123; int tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; &#125; &#125; // nums[from] &lt;-&gt; nums[to] // to &lt; len private static void reserve(int from, int to) &#123; int offset = 0; while (offset &lt; (to - from + 1) / 2) &#123; swap(from + offset, to - offset); offset++; &#125; &#125; // boolean -&gt; 是否找到了新的排列 private static boolean getNextPermutation() &#123; // 1. 找到第一个升序 int len = nums.length; int i = len - 2; while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123; i--; if (i &lt; 0) // 小于零说明已经找到全部排列 return false; &#125; // 2. 在右侧的降序中找最接近i的那个大数 int j = len - 1; while (i &lt; j &amp;&amp; nums[i] &gt;= nums[j]) &#123; j--; &#125; // 3. 交换升序数和最小大数 swap(i, j); // 4.反转尾部字符串 reserve(i + 1, len - 1); return true; &#125; public static void main(String[] args) &#123; System.out.println(\"the \" + ++count + \"th permutation: \" + Arrays.toString(nums)); int count2 = 20; while (getNextPermutation() &amp;&amp; count2-- &gt; 0) &#123; System.out.println(\"the \" + ++count + \"th permutation: \" + Arrays.toString(nums)); &#125; &#125;&#125; 复杂度为O(n!)，和使用递归法求全排列是一样的 总结 好好体会其中的序列的理论 参考 编程之法 面试和算法心得","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"算法题解","slug":"算法/算法题解","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"排列组合","slug":"排列组合","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"}]},{"title":"八皇后问题","slug":"algorithm/classical/classical-algorithm-n-queens","date":"2020-07-15T11:23:08.000Z","updated":"2021-07-22T01:19:58.360Z","comments":true,"path":"2020/07/15/algorithm/classical/classical-algorithm-n-queens/","link":"","permalink":"http://yoursite.com/2020/07/15/algorithm/classical/classical-algorithm-n-queens/","excerpt":"经典递归回溯算法-八皇后问题及其推广的n皇后问题 一个比计算机历史都老的问题 递归回溯算法的经典应用场景 关于无模型的可计算问题","text":"经典递归回溯算法-八皇后问题及其推广的n皇后问题 一个比计算机历史都老的问题 递归回溯算法的经典应用场景 关于无模型的可计算问题 问题描述 首先给没下过国际象棋的同学们科普一点背景知识，在国际象棋中，棋盘是8*8的，一共64个格子，皇后是其中最强的棋子，走法类似中国象棋中的车（可以前往横向和纵向的任何一个未被阻挡的位置），但是国际象棋中的皇后，除了横向和纵向外，还可以移动斜方向，如下图（绿色为皇后可以前往的位置，有时在术语中称“占领区”或者“看守线”）： 回到我们的八皇后问题的定义来： 在一个8*8的棋盘上放置8个皇后 找到一种放法，可以使这8个皇后无法互相攻击，和平共处 这个问题最早是由一个19世纪的棋手提出来的，后来由原本的“八皇后问题”推广到了“n皇后问题”，也就是变化数字8，在一个n*n的棋盘上放置n个互相不攻击的皇后。一个基本的八皇后的解法，其中8个皇后，无论横纵还是斜向，都无法互相攻击： 关于可计算性和这个问题的一点点数学背景 类似七桥问题，历史上很多数学家都研究过这个八皇后问题，包括高斯（数学王子，数论大师）和康托（朴素集合论创始人，历史上真正的数学天才之一）等一众大佬都研究过这个问题，但是一直没有找到特别好的方式去找到八皇后问题中的数学模型，目前已知的方法只能通过极其复杂的行列式去进行推导，研究结果也大多是某些特定的放置图形，或者当n为某个数时有多少种放置法 关于编程问题的数学模型，如果你去计算一个{1…n}的等差数列的和，可以用while循环去一个个加起来，但是这个问题本身是有一个公式的，也就是(1+n)*n*0.5，所以等差数列的求和问题是一个有内在数学模型的问题，但是八皇后问题没有内在数学模型，只能通过计算机的特殊性质去求解，比如大规模迭代或者递归，这都是人不擅长，但是机器尤其擅长的问题，对于一个问题是否可以通过计算机的递归函数模型来计算的问题称为可计算问题，是离散数学的重要课题之一 n皇后问题中，关于n的取值和相关解的数目的表格： n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 … U 1 0 0 1 2 1 6 12 46 92 341 1787 9233 45752 … D 1 0 0 2 10 4 40 92 352 724 2680 14200 73712 365596 … n代表在n*n的棋盘上放置n个皇后，U为独立解，D为互不相同解（某些解通过旋转棋盘会重叠，去掉可通过旋转和对称来重叠的解成为独立解）。现在还没有已知公式可以对n计算n皇后问题的解的个数 可以看到我们的八皇后问题，本身拥有92个解，其中有12个独立解 只有n&gt;=4时n皇后问题才成立 问题分析 想到这个问题的第一步其实很简单，既然是棋盘，我们直接枚举所有的情况，然后为每一种情况计算冲突，如果发现有冲突，则放弃本次情况，计算下一个情况，这么做看似简单，其实实施起来还是比较困难的，在一个64格的棋盘长摆放8个棋子，其实就是一个C(64,8)的组合，结果是4426165368，也就是你的程序要至少计算44亿次才能算出最终答案，这简直就是噩梦。但是回想一下小学数学，就会发现有一个巨大的优化方案，那就是抽屉原理 抽屉原理：在n个抽屉中随机放n+1个球，那么至少会有一个抽屉里会出现&gt;=1个球。抽屉原理说明了在有限资源的抢占中会出现平均化和“排挤”现象 依旧观察我们之前给出的那个八皇后问题的解，会发现每个皇后都独占一个列和一个行，在不考虑斜向的情况下，会出现下面的情况，每个皇后独占一个行和一个列，对于第0行的皇后占领后，其实剩下7个棋子是在抢占一个7*7的子棋盘： 这就很明显了啊，使用一个{1,2,3,4,5,6,7,8}的排列组合，就可以轻松解决棋子之间的行列冲突，一个P(8,8)的全排列结果是40320，可比之前的44亿小多了，我们可以枚举一个全排列，在此基础上，检查其中的斜向是否存在冲突（互相攻击），如果冲突则转向下一个情况，由此出现了我们的第一个解法，全排列枚举法： 1. 全排列枚举法 我们这里设置一个一维数组locations来表示棋盘，其中的每一个位置i都代表第i行，locations[i]=j表示该行的皇后在第j列，比如有locations={0,1,2,3,6,7,5,4}，则有下图的棋盘： nextPermutation()是一个全排列函数，将我们的locations数组排列成下一个全排列序列，我这里使用的是字典序算法构造的全排列，在本题中无需深究（可以看我另一篇讲字典序全排列的博客），无论是递归法构造全排列还是字典法构造全排列，都是一样的，在本体中只要知道，每成功调用一次nextPermutation()函数，函数会从{1,2,3,4,5,6,7,8}-&gt;{1,2,3,4,5,6,8,7}或者{0,1,2,3,6,7,5,4}-&gt;{0,1,2,3,7,4,5,6}，也就是转换成它的下一个全排列序列，{0,1,2,3,6,7,5,4}-&gt;{0,1,2,3,7,4,5,6}的示例图如下： hasConflict(current_row)则是冲突判断函数，由于本题用来全排列，横纵方向是绝对不会冲突的（每行只有一个皇后，且每个皇后都在0-7号不同的列上），只需计算行数差是否等于列数差即可，也就是|a-b|==|locations[a]-locations[b]|?，若相等，则说明在同一条斜线上，会发生互相攻击，下面就是一种会发生攻击的例子： 将P(8,8)=40320次枚举全部完成，就可以算出其中有多少次成立了，且这个解法可以从八皇后推广到n皇后，完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import java.util.Arrays;public class MainWithPermutation &#123; private static int count; private static int n; private static int[] locations; static &#123; // 初始化计数器，记录有多少种解法 count = 0; // 初始化棋盘规模，这里八皇后，所以是8 n = 8; // 初始化棋盘 locations = new int[n]; for (int i = 0; i &lt; n; i++) &#123; locations[i] = i; // locations=&#123;0,1,2,3,4,5,6,7&#125; &#125; &#125; // 将目前待定位置（某个行数字）和其它确定（之前的，不包括之后的）位置比较，看是否合法 // 无冲突即为false private static boolean hasConflict(int current_row) &#123; for (int previous_row = 0; previous_row &lt; current_row; previous_row++) &#123; // 是否压线（存在互相攻击），压线则true if ((Math.abs(current_row - previous_row) == Math.abs(locations[current_row] - locations[previous_row]))/* || (locations[current_row] == locations[previous_row]) */) &#123; return true; &#125; &#125; return false; &#125; // 全排列函数的交换子函数，交换数列的某两位 // &#123;1,2,3,4&#125;.swap(0,3) -&gt; &#123;4,2,3,1&#125; private static void swap(int a, int b) &#123; if (a &lt; locations.length &amp;&amp; b &lt; locations.length) &#123; int tmp = locations[a]; locations[a] = locations[b]; locations[b] = tmp; &#125; &#125; // 全排列函数的反转子函数，会将某一长度的尾部反转 // &#123;1,2,3,4&#125;.reserve(1,3) -&gt; &#123;1,4,3,2&#125; private static void reserve(int from, int to) &#123; int offset = 0; while (offset &lt; (to - from + 1) / 2) &#123; swap(from + offset, to - offset); offset++; &#125; &#125; // 全排列函数的主体，会将数列locations排列成下一个排列序 // boolean -&gt; 是否找到了新的排列，若无下一个全排列了则false private static boolean nextPermutation() &#123; // 1. 找到第一个升序 int len = locations.length; int i = len - 2; while (i &gt;= 0 &amp;&amp; locations[i] &gt;= locations[i + 1]) &#123; i--; if (i &lt; 0) // 小于零说明已经找到全部排列 return false; &#125; // 2. 在右侧的降序中找最接近i的那个大数 int j = len - 1; while (i &lt; j &amp;&amp; locations[i] &gt;= locations[j]) &#123; j--; &#125; // 3. 交换升序数和最小大数 swap(i, j); // 4.反转尾部字符串 reserve(i + 1, len - 1); return true; &#125; // 打印函数，将棋盘输出在控制台上 private static void printQueen() &#123; System.out.println(\"the \" + count + \"th map for queens: \"); for (int i = 0; i &lt; locations.length; i++) &#123; for (int j = 0; j &lt; locations.length; j++) &#123; if (j == locations[i]) &#123; System.out.print(\"Q, \"); &#125; else &#123; System.out.print(\"., \"); &#125; &#125; System.out.println(\"\"); &#125; &#125; // 运行 public static void main(String[] args) &#123; do &#123; int row; for (row = 0; row &lt; locations.length; row++) &#123; if (hasConflict(row)) break; &#125; if (row &gt;= n) &#123; count++; printQueen(); &#125; &#125; while (nextPermutation()); &#125;&#125; 字典序全排列的复杂度是O(n!)，整体的复杂度可以自己算一下复杂度（作者偷懒） 2. 递归回溯法 这个是八皇后问题的最经典的解法，要知道八皇后问题在计算机领域为人所知就是因为巨佬Dijkstra在1972年的结构化编程的论文里，以八皇后问题为例，讲解了他所研究的深度优先搜索回溯算法（图论中计算最短路径的Dijkstra算法就是以他的名字命名的） 所谓的回溯法想必在大学里学数据结构时都接触过，简单来说就是维护一个记录型结构，并把问题的求解划分成n个子问题，第k层问题的解决依赖于第k+1层问题，且第k层会为第k+1层提供必要数据，当k+1层出错时，程序会回到第k层，k层调整部分参数后，调用新的第k+1层，在不断的调用和回溯过程中，最终达到解决问题所需要的条件（可用解）。说白了回溯法就是走迷宫：从一条路往前走，能进则进，不能进则退回来，换一条路再试 这里给出在4*4棋盘中进行的4皇后问题，各位可以跟着箭头走一边，从而感受一下回溯过程是怎么发生的，尤其是其中的“层层深入”和回溯现象： 众所周知啊，递归的问题要么死活看不懂，一旦看懂就会特别简单，所以多说无益，还是直接看代码吧，在看实际代码前，做几点解释： 在全排列方案中，使用的一维数组locations作为棋盘，这里则是用了一个二维数组，本质是没有区别的，只是在递归过程中，二维的棋盘方便理解而已，观众老爷们可以自己修改代码，把二维棋盘换成一维棋盘 由于棋盘换了，所以重新编写了冲突检测函数，会分别检测当前棋子的北侧，系北侧和东北侧（也就是纵向正上方，斜向左上方和斜向右上方） 阅读使用了递归算法的代码，一定要找到“我差遣我自己”的代码，也就是出现在函数体内的函数头，并重点关心其中的数据变化，这样可以很快理解一个递归算法 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.util.Arrays;public class MainWithBacktrack &#123; private static int count; private static int n; // 在n*n的棋盘上部署n个皇后 private static char[][] board; // 双重数组，棋盘 static &#123; // 初始化计数器 count = 0; // 初始化n，表示n个皇后在n*n的棋盘上，这里是八皇后，所以n=8 n = 8; // 初始化棋盘，注意这里是二维棋盘，初值是'.'，表示没有棋子 board = new char[n][n]; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board.length; j++) &#123; board[i][j] = '.'; &#125; &#125; &#125; // 这是一个递归函数 // backtrack(n)表示放置第n行的皇后，每一行的下棋都是一个k子问题 private static void backtrack(int row) &#123; // 放置第8行了，说明之前的0-7号都不冲突了，解成立了 // 计数后输出 // 这里其实就是递归出口 if (row == n) &#123; count++; printQueen(); return; &#125; for (int col = 0; col &lt; board.length; col++) &#123; // 如果当前合法，则将本格值设为'Q'，继续递归下一行的皇后 if (isValid(row, col)) &#123; board[row][col] = 'Q'; backtrack(row + 1); // by rows board[row][col] = '.'; // 这里是回溯清零，本次递归完成后，已经置'Q'的位置要还原，不能影响下一次递归 &#125; &#125; &#125; // 工具函数，打印当前棋盘 private static void printQueen() &#123; System.out.println(\"the \" + count + \"th map for queens: \"); for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board.length; j++) &#123; System.out.print(board[i][j] + \", \"); &#125; System.out.println(\"\"); &#125; &#125; // 合法判定 private static boolean isValid(int row, int col) &#123; // north for (int offset = 1; offset &lt;= row; offset++) &#123; if (board[row - offset][col] == 'Q') &#123; return false; &#125; &#125; // north-west for (int offset = 1; offset &lt;= row &amp;&amp; offset &lt;= col; offset++) &#123; if (board[row - offset][col - offset] == 'Q') &#123; return false; &#125; &#125; // north-east for (int offset = 1; offset &lt;= row &amp;&amp; offset &lt; board.length - col; offset++) &#123; if (board[row - offset][col + offset] == 'Q') &#123; return false; &#125; &#125; return true; &#125; // 运行 public static void main(String[] args) &#123; backtrack(0); &#125;&#125; // 作者偷懒了，还是自己算一下复杂度吧 运行测试 之前给出来n皇后的结果表，上面的代码我都自己跑过了，结果都是符合的，你们可以自己跑一下 总结 八皇后问题是一个非常经典的递归回溯法的应用，应该自己写一下，好好掌握。在本质上，这是一个树形深度递归的问题，感兴趣的旁友可以自己继续深入，而不是仅仅看到表明问题的八皇后 如果发现文中错误，请在评论区留言或者直接邮件我，冒个泡也行 参考 wiki-八皇后问题 什么是八皇后问题？ 回溯法(backtracking algorithm)求解N皇后问题(N-Queens puzzle)","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"经典算法","slug":"算法/经典算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"回溯问题","slug":"回溯问题","permalink":"http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/"}]},{"title":"Java的Context上下文","slug":"java/others/context-concept-in-java","date":"2020-07-04T14:52:20.000Z","updated":"2021-07-22T01:19:58.370Z","comments":true,"path":"2020/07/04/java/others/context-concept-in-java/","link":"","permalink":"http://yoursite.com/2020/07/04/java/others/context-concept-in-java/","excerpt":"对Java中的Context上下文概念的理解","text":"对Java中的Context上下文概念的理解 Java中Context是一个很常见的概念，在各大IOC容器和框架中经常可以看到，我第一次看到这个东西是servlet里的ServletContext对象，Context单词的本意是“语境”或者“上下文”，大部分技术博客也都直接拿上下文来称呼，但是从直观上让人感觉乖乖的，让人一时有点理解不能，这里针对Context的本质做一点讨论 Java中的几个Context例子 这里给出几个常见的Context，来感受一下这个上下文到底是个什么东西： 1. JNDI的InitialContext类和Context接口 JNDI（Java Naming and Directory Interface），也就是Java命名和目录接口中的一个核心类javax.naming.InitialContext，它实现了一个javax.naming.Context接口，InitialContext类会读取JNDI的一些配置信息，并内含对象和其在JNDI中的注册名称的映射信息。这里给出javax.naming.Context接口的一段文档： This interface represents a naming context, which consists of a set of name-to-object bindings. It contains methods for examining and updating these bindings. 大致意思：这个接口代表了一个命名上下文，其包含了一系列的“名称到对象”映射的集合，同时携带了检查和更新这些绑定的相关方法 这里看一段JBOSS中获取MBean的远程调用类的代码： 123// 通过InitialContext中JNDI注册的名称“jmx/invoker/RMIAdaptor”来获得RMIAdaptor对象InitialContext ic=new InitialContext();RMIAdaptor server=(RMIAdaptor)ic.lookup(\"jmx/invoker/RMIAdaptor\"); 这里的行为类似一个Hash表，存储String-&gt;Object的映射关系 2. Spring的ApplicationContext接口 ApplicationContext接口是Spring框架的核心接口之一，其代表的context也是Spring的核心概念之一，直接来看一段代码来体会一下： 123ApplicationContext context = new ClassPathXmlApplicationContext(\"ioc/Beans.xml\");HelloWorld helloWorld = (HelloWorld) context.getBean(\"helloWorld\");helloWorld.sayHello(); 在本例中，ApplocationContext代表一个抽象概念，表示从xml中注册的元数据中加载出的一个“语境”，也就是标注了相互关系的元数集合 这段代码从配置文件Beans.xml中读取了各个Bean对象的元数据，返回了一个包含了所有注册Bean的context对象，我们可以从context中获取某个xml中注册的Bean对象，在这里，可以很清晰体会到，context的大致含义就是一个对象容器，或是一个运行环境 3. J2EE的ServletContext接口 ServletContext是J2EE四大域之一，一个Web容器（比如Tomcat）可以运行多个Web应用（部署层面讲对应多个war包），Web容器在启动时，会为每个Web应用程序创建一个对应的ServletContext对象，代表当前Web应用，被所有访问者（客户端）共享 ServletContext对象会被其所属的Web应用（每个Web应用仅有一个ServletContext对象）中的所有Servlet共享，因此Servlet对象之间可以通过ServletContext对象来实现通讯，自此ServletContext对象通常也被称之为context域对象，具体关系可以看下图： 基本的使用代码，在ServletContext对象中写入一个共享数据（本应用的其它Servlet都可以访问）： 12ServletContext servletContext = getServletConfig().getServletContext();servletContext.setAttribute(\"boy who lived\", \"harry potter\"); 对Context的理解 关于context这个词，本意是”上下文“，”语境“和”前后关系“，在语言学中本来的作用是对抗歧义，防止”断章取义“，本质上是一组特定发生的对象及其之间相互关系的集合，如”在人造工具的帮助下，人类是这颗星球上最快的动物“，如果忽略上下文就容易造成断章取义的”人类是这颗星球上最快的动物“，表意上就没那么清晰了，在这种情况下，”上下文“的意思就是”语言的具体环境“ 在ServletContext和如ApplicationContext的例子中，其名下的各个实例对象，是可以通过context来进行相互通信的，在这个情况下，context成为了某种承载了公用信息的公告板，是发生相互作用关系的媒介，这和context本意的”前后关系“是一致的。再比如访问JNDI的Context，他的上层是JNDI服务器（可能是远程的），下层是你的应用程序，他的作用也是建立一个通道让你能访问JNDI服务器，同时也让JNDI服务器接受你的请求，同样起到交互作用 从字面意义上看context翻译上下文其实没有任何问题，就是理解起来不太方便而已，在大多数场合下，如ApplicationContext，直接理解成一个”承上启下“的运行时环境或者对象容器即可，多数情况下一个Context实例也就是一个特殊关系集合，只管作为container使用即可 总结 翻译的多样性是持续存在的，比如container这个词，可以作数据结构中的数据容器，docker的虚拟机容器，也可以是单纯的一堆对象的管理器，说到底只是个取名，只是一个抽象概念，应该关注其具体代表的职能，而不是纠结字眼，就比如”吐槽“这个词，论坛里都在用，要你说出具体意思估计回答千奇百怪的。如果一定要我取一个翻译，我会把把context翻译成”语境/前后关系容器/交互运行环境“。以上 参考 java上下文Context类","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"经典算法题解-两个子串","slug":"algorithm/exercise/question-two-substrings","date":"2020-06-10T07:58:16.000Z","updated":"2021-07-22T01:19:58.367Z","comments":true,"path":"2020/06/10/algorithm/exercise/question-two-substrings/","link":"","permalink":"http://yoursite.com/2020/06/10/algorithm/exercise/question-two-substrings/","excerpt":"","text":"经典算法题解-两个子串 施工ing 这个是2018年京东校招的笔试题 本质是KMP算法子问题的“最大相同前后缀”的变种（也就是next[]数组的构造问题），我的另一篇博客最大相同前缀后缀问题有讨论，看本文前请先花20分钟看一下 问题描述 问题分析 如果有好好读完我那篇关于前后缀的文章，那么这个题目的解答 示例代码 123456789101112131415161718192021222324252627282930313233class Solution &#123; static int[] getNext(String pat) &#123; int len = pat.length(); int[] next = new int[len]; next[0] = 0; for (int i = 0, j = 1; j &lt; len; j++) &#123; while (pat.charAt(i) != pat.charAt(j) &amp;&amp; i &gt; 0) i = next[i - 1]; if (pat.charAt(i) == pat.charAt(j)) next[j] = ++i; else next[j] = 0; &#125; return next; &#125; public String longestPrefix(String s) &#123; int len = s.length(); if (len &lt; 2) &#123; return \"\"; &#125; else &#123; return s.substring(0, getNext(s)[len - 1]); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"算法题解","slug":"算法/算法题解","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"习题","slug":"习题","permalink":"http://yoursite.com/tags/%E4%B9%A0%E9%A2%98/"}]},{"title":"经典算法题解-最长快乐前缀","slug":"algorithm/exercise/question-longest-happy-prefix","date":"2020-06-10T07:48:16.000Z","updated":"2021-07-22T01:19:58.365Z","comments":true,"path":"2020/06/10/algorithm/exercise/question-longest-happy-prefix/","link":"","permalink":"http://yoursite.com/2020/06/10/algorithm/exercise/question-longest-happy-prefix/","excerpt":"最长快乐前缀问题 题目描述来源：LeetCode-最长快乐前缀 题目难度：困难 本题是KMP算法的应用变种，阅读本文前最好阅读一下我的另一篇博客最大相同前缀后缀问题中对于最大相同前缀后缀问题的讨论","text":"最长快乐前缀问题 题目描述来源：LeetCode-最长快乐前缀 题目难度：困难 本题是KMP算法的应用变种，阅读本文前最好阅读一下我的另一篇博客最大相同前缀后缀问题中对于最大相同前缀后缀问题的讨论 问题描述 定义：快乐前缀，是在原字符串中既是非空前缀也是后缀（不包括原字符串自身）的字符串 问题要求： 给你一个字符串s，请你返回它的最长快乐前缀 如果不存在满足题意的前缀，则返回一个空字符串 示例： 给出S = &quot;ababab&quot;，输出&quot;abab&quot; 给出S = &quot;leetcodeleet&quot;，输出&quot;leet&quot; 给出S = &quot;a&quot;，输出&quot;&quot; 问题分析 如果你有好好看完我开头提到的那篇讲前后缀的文章，那么这个题目的解答显而易见了，其实就是KMP算法中next[]数组的定义，通过遍历字符串，递推构造就行，代码甚至可以直接从最大相同前缀后缀问题里抄过来，只要针对长度为0和1的输入进行一点点调整即可。不多废话，直接看代码 代码示例 这里只给出Java的示例，基本是next[]的简单修改，如果看不懂请回到我那篇讲前后缀问题的博客看一下 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; static int[] getMax(String pat) &#123; int len = pat.length(); int[] max = new int[len]; max[0] = 0; int i = 0; // 表示当前最大共缀长度的候选值 int j = 1; // 从第二位开始遍历 while (j &lt; len) &#123; if (pat.charAt(i) == pat.charAt(j)) max[j++] = ++i; else if (i == 0) max[j++] = 0; else i = max[i - 1]; // 递推核心 &#125; return max; &#125; public String longestPrefix(String s) &#123; int len = s.length(); if (len &lt; 2) &#123; return \"\"; &#125; else &#123; return s.substring(0, getMax(s)[len - 1]); &#125; &#125;&#125; 时间复杂度O(N)，空间复杂度O(N) 在LeetCode上的运行结果如下，可以看出整体效率还是比较高的： 总结 这一类的问题很常见，基本就是某一个经典算法的子问题，比如本题就是KMP算法的子问题，也就是求next[]数组的问题，如果你发现代码有改进之处，或者发现了bug，记得在评论区bb我，感谢阅读","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"算法题解","slug":"算法/算法题解","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"习题","slug":"习题","permalink":"http://yoursite.com/tags/%E4%B9%A0%E9%A2%98/"}]},{"title":"模式匹配的KMP算法","slug":"algorithm/classical/classical-algorithm-kmp","date":"2020-06-05T05:43:57.000Z","updated":"2021-07-22T01:19:58.359Z","comments":true,"path":"2020/06/05/algorithm/classical/classical-algorithm-kmp/","link":"","permalink":"http://yoursite.com/2020/06/05/algorithm/classical/classical-algorithm-kmp/","excerpt":"","text":"字符串模式匹配中的KMP算法 施工ing 施工中…","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"经典算法","slug":"算法/经典算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"算法/经典算法/字符串","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"最大相同前缀后缀问题","slug":"algorithm/classical/classical-algorithm-maximum-same-prefix-suffix","date":"2020-06-04T07:14:17.000Z","updated":"2021-07-22T01:19:58.360Z","comments":true,"path":"2020/06/04/algorithm/classical/classical-algorithm-maximum-same-prefix-suffix/","link":"","permalink":"http://yoursite.com/2020/06/04/algorithm/classical/classical-algorithm-maximum-same-prefix-suffix/","excerpt":"经典字符串算法-最大相同前缀后缀问题 这个是学习KMP算法的前置问题，已经有几十年历史了 本质是个很经典的有限状态机 我看过很多关于这个问题的博客，要么是特别长根本看不懂，要么根本就是错的，所以我决定自己写一篇，中间解释部分有点长，喜欢直接看源码可以直接翻到源码那个节，算法比较难理解，但是实现代码就一点点，很短很巧妙","text":"经典字符串算法-最大相同前缀后缀问题 这个是学习KMP算法的前置问题，已经有几十年历史了 本质是个很经典的有限状态机 我看过很多关于这个问题的博客，要么是特别长根本看不懂，要么根本就是错的，所以我决定自己写一篇，中间解释部分有点长，喜欢直接看源码可以直接翻到源码那个节，算法比较难理解，但是实现代码就一点点，很短很巧妙 问题描述 首先了解一个概念，有一个字符串ABCDE，其中从首字母A开始的子字符串，如AB或ABC，称为这个字符串的前缀，同样的以尾字母结束的子字符串，如CDE或DE，称后缀。其中，子字符串的长度len必须有0&lt;len&lt;整体长度，也就是说子字符串必须是个真子集，A是ABCDE的前缀，ABCD是ABCDE的前缀，但ABCDE不能作为其本身的子字符串 在了解完前后缀概念后，我们的问题来了：给定一个字符串S，找出其相同前缀后缀的最大长度 示例：有字符串ABCAB，其最大的相同前缀和后缀是AB，所以这个字符串的最大相同前缀后缀长度为2 同时在此给出几个名词（我自己创的或者习惯称呼，为的是表达方便），一共三处： 对于一个字符串ABCAB，如果其拥有相同的前缀后缀存在，那么称这个字符串为共生串，这其中拥有对应相同的后缀的前缀称共生前缀，对应的后缀称共生后缀，统称共生缀，简称共缀，上图中的ABCAB就是一个共生串，其中的AB则是这个共生串的最大共生缀，也是唯一共生缀 对于一个字符串ABCD，它会拥有几个子串，也就是A，AB和ABC，它们连同ABCD呈现出一种成长性（如下图），在这里我们称A为AB的前驱字符串，AB为ABC的前驱字符串（注意前趋串本身也是一个前缀串） 我们都知道字符串本质是一个字符数组，那么对于字符串S = &quot;ABCD&quot;其实等同于S = {'A','B','C','D'}，所以S[0]==‘A’，同时有一种切片描述，S[0..2]表示S[0]到S[2]之间的所有字符组成的串，也就是说S[0..2]==“AB” 共生缀的对称性 观察这样一个共生串ABACABA，它有两个共生缀A和ABA，在这里可以看出，当一个共生串拥有一个以上的共生缀的时候，其内部就会展现出一种对称性，在此不必要深究其数学证明，只要在视觉上对其有一个概念即可 下面是ABACABA的示意图，其中的4个被涂红的A，展现出了很明显的对称性。之后我们会看到，这几个A在实际意义上，指代的是同一个字符： 问题分析 一开始看见这个问题，想到的方法自然是万能的暴力for循环啦，不多bb，还是拿ABACABA这个字符串开刀： 1. 暴力for循环 基本流程如下： 考虑共缀长度为1，那我们直接比较首尾字符就行了，也就是S[0]和S[6]，我们发现都是A，所以有共缀成立，为A，长度为1，如下所示： 考虑是否有更长的共缀长度，于是我们将考量长度+1，开始考虑S[0..2]和S[5..7]，发现并不匹配，所以不存在长度为2的共缀，如下所示（黄色表示失败）： 我们不甘心，只能继续查找更长的字符串，看是否有奇迹发生，于是在长度为3的共缀串中，发现匹配了，如下图所示： 接下来继续尝试4和5和6，但是均为失败，所以最大共缀就是之前测到的ABA，长度为3，下面是完整的一览（3以后我涂色分层了，为了直观一点，黄色失败，红色成功）： 示例代码如下，我用Java实现的，随便看看就行了： 1234567891011121314151617181920212223public class MaxPrefix &#123; public static void main(String[] args) &#123; String s = \"abacaba\"; int len = s.length(); for (int m = 1; m &lt; len; m++) &#123; for (int i = 0, j = len - m; i &lt; m &amp;&amp; j &lt; len; i++, j++) &#123; if (s.charAt(i) != s.charAt(j)) &#123; break; &#125; if (i == m - 1) &#123; // 如果存在共缀则输出共缀长度 System.out.println(m); &#125; &#125; &#125; &#125;&#125;// 最终输出// 1// 3 时间复杂度O(N^2)，效率不是很高，毕竟是暴力双重for循环 2. 递推数组 上面的例子只是为了方便理解，其实由于效率低等原因，我们一般更愿意采用本节的方案，使用递归关系求解，这个算法很有趣，而且是KMP算法的核心。对比上面的只能算一个字符串，递推数组的方案不仅能求出我们的字符串本体的共缀，甚至能连同求出其子串的共缀 这里我们使用字符串ABACABAB作为示例，我们在这里建立一个max[]数组，数组元素代表当前长度下，字符串最长共缀，你们可以看下图感受一下： 在正式开始构建之前，观察这么一个有趣的现象，还是看我们上面的ABACABAB，但是我稍微涂了一点颜色，如下所示： 观察上图，我们可以发现，对于字符串ABACABAB，它是一个共生串，且共生缀长度为2（也就是满足大于1），那其实很清晰可以看到，它的前驱串ABACABA也是一个共生串且共生缀长为1，于是我们可以得到一个有趣的结论，也就是共生缀长度超过1的共生串的前驱串也必然是一个共生串，我称之为“有爸爸的前提是先有爷爷定律”，这个结论是递推数组的核心，也就是说，我们在max[k]的数据受到max[k-1]的影响，在考虑在某个位置（本例中为S[7]=B）是否构成共缀的时候只要考虑其之前的字符串（前缀或前趋）是否是个共生串（本例中为S[0..7]=“ABACABA”，其为共生串且共缀为ABA，ABA本身也是一个共生串，共缀为A）即可，然后我们只要校验尾位即可，不需要像暴力for里跟二胡卵子一样每一位都单独计算了。借由这个性质，我们使用递推法构造数组成为可能 基于以上事实，那其实我们构建递推数组max[]的核心流程也已经很明确了，示例依旧是待检字符串S = &quot;ABACABAB&quot;&quot;，有以下步骤： 如果位置S[k]的前趋串S[0..k]是一个共生串，且共缀长度为j（也就是max[k-1]=j），那么直接比较S[j]和S[k]，若匹配，则j+1就是max[k]的值，如示例字符串ABACABAB的S[6]位置，按照我们的“有爸爸的前提是先有爷爷定律”，其前趋串ABACAB拥有共缀AB，且S[j]=S[2]=A和S[k]=S[6]=A匹配，所以max[6]顺理成章喜加一，有max[6]=max[5]+1=2+1=3，如下图所示： 如果不匹配，说明max[k]&lt;=max[k-1]=j，如示例字符串ABACABAB的S[7]位置，有S[3]=C!=S[7]=B，按照有爸爸的前提是先有爷爷定律，我们继续考虑前趋串来找这个“爷爷”，幸运的是ABAC尽管和ABAB不匹配，但是ABA本身也是一个共生串，其共缀为A，在第二次迭代后，S[0..2]=AB和S[6..8]=AB匹配，所以max[7]=max[2]+1=1+1=2，如下图所示： 如果运气不太好，无论怎么迭代前趋串，以及前趋串的前趋串，一直找不到这个“爷爷”，那没办法了，没“爷爷”自然没“爸爸”，那也自然没有“儿子”了，按照有爸爸的前提是先有爷爷定律，前趋串不是共生串，且本身单字符匹配也不成立，max[k]就只能置零，如S[3]位置，找不到“爷爷”，本身也不匹配（指S[0]!=S[3]），最后只能置零，也有稍微幸运一点的，如S[4]，虽然找不到“爷爷”，但是本身单字符匹配成立了（指S[0]!=S[3]=A），所以max[4]=0+1=1，如下图所示（黄色失败红色成功）： bb了这么久，估计不少人看得也云里雾里的，对于理解这种含递推过程的问题来说很正常，多看几遍就有感觉了，自然而然就看懂了，这里直接给出相关的Java代码： 123456789101112131415161718192021222324252627282930313233343536public class Kmp &#123; // 其实next[]数组在KMP算法中实际应用时会有一点点小变化，但是这里是为了计算共缀，依旧采用next的命名 private static int[] getNext(String pat) &#123; int len = pat.length(); if (len &lt; 2) return new int[]&#123;0&#125;; // 字符串长度0或1直接返回 int[] next = new int[len]; next[0] = 0; int i = 0; // 表示当前最大共缀长度的候选值 int j = 1; // 从第二位开始遍历 while (j &lt; len) &#123; if (pat.charAt(i) == pat.charAt(j)) &#123; next[j++] = ++i; // 如果第j位直接匹配，则最大值顺延。且j进入下一位 &#125; else if (i == 0) &#123; next[j++] = 0; // 找不到“爷爷”，本身又不匹配，那就只能置0 &#125; else &#123; i = next[i - 1]; // 递推核心，寻找下一层的最大前缀 &#125; &#125; return next; &#125; public static void main(String[] args) &#123; System.out.println(Arrays.toString(getNext(\"ABACABAB\"))); // 输出结果 // [0, 0, 1, 0, 1, 2, 3, 2] // 对应有txt &lt;-&gt; max[] // A B A C A B A B // 0 0 1 0 1 2 3 2 &#125;&#125; 看完了代码，我们在针对字符串S = &quot;ABACABAB&quot;&quot;来就进行一次完整的计算，建议结合上面的源码一起看： S[0]=A，完整字串A，长度1,不存在前后缀和匹配问题，直接置0，最终结果max[0]=0 S[1]=B，完整字串AB，本体单字符S[0]=A!=S[1]=B，且没有前趋（因为max[0]=0，不是一个合法的共生串）给它找“爷爷”，最终置0，最终结果max[1]=0 S[2]=A，完整字串ABA，依旧没有前趋串给它“找爷爷”，所以直接比较本体的S[2]，本体单字符S[0]=A==S[2]=A，匹配成立，最终结果为max[2]=max[1]+1=0+1=1 S[3]=C，完整字串ABAC，有前趋串ABA，按照我们顺延的做法，比较AB和AC，失败了，同时迭代ABA的共缀A无果，所以最终悲惨置0，最终结果max[3]=max[0]+0=0+0=0 S[4]=A，完整字串ABACA，无前趋共生串，但本体单字符S[0]=A==S[4]=A，匹配成立，所以最终结果max[4]=max[0]+1=0+1=1 S[5]=B，完整字串ABACAB，有前趋共生串ABACA且共生缀A，匹配单体S[1]=B==S[5]=B，匹配成立，结果顺延，最终结果max[5]=max[4]+1=1+1=2 S[6]=A，完整字串ABACABA，有前趋共生串ABACAB且共生缀AB，匹配单体S[2]=A==S[6]=A，匹配成立，结果顺延，最终结果max[6]=max[5]+1=2+1=3 S[7]=B，完整字串ABACABAB，有前趋共生串ABACABA且共生缀ABA，但是匹配单体S[3]=C!=S[7]=B失败，所以按照有爸爸的前提是先有爷爷定律/共生缀长度超过1的共生串的前驱串也必然是一个共生串定律开始“找爷爷（有效共缀）”，其前趋缀ABACABA的共生缀本身也是共缀为A的共生缀，最终S[0..2]=A+B匹配S[6..8]=A+B，最终结果max[7]=max[2]+1=1+1=2 注意，在这里，我额外用绿色标出了4个A的位置，可以返回前面，看一看我说的对称性，你就知道，这个图到底什么意思了 同时观察S[7]=B指出的箭头，这个其实代表了算法实现中的一个目的，找到共生缀，其实就是当前位的S[k]的字符X是否在之前的共生串中出现过，所谓的“找爷爷”，其实就是在借由递推不同层级的前缀来找这个字符X 最终得到的max[]数组为： 总结 到此为止，就完整地完成了字符串的最大相同前后缀问题，我们求出来的max[]数组其实是KMP算法中next[]数组的基础，可以说理解了最大相同前后缀问题就是理解了KMP算法（这个算法是出了名的难理解）。这个问题的本质是是一个关于有限状态自动机的算法，但是在这里体现得不明显，在另一篇关于KMP算法的有限自动机问题的博文里，我会详细表述一下。本文的问题解答，因为涉及递推，一开始不是很好理解，没什么捷径，自己多看代码，多画图，来几遍有感觉了，自然就会理解的。如果你发现了bug，或者有自己的想法和优化方案，请给博主发邮件，或者在评论区戳我，感谢阅读(′▽`〃) 参考 编程之法 面试和算法心得","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"经典算法","slug":"算法/经典算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"算法/经典算法/字符串","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"经典算法题解-最小值栈","slug":"algorithm/exercise/question-min-num-of-stack","date":"2020-05-29T09:00:00.000Z","updated":"2021-07-22T01:19:58.365Z","comments":true,"path":"2020/05/29/algorithm/exercise/question-min-num-of-stack/","link":"","permalink":"http://yoursite.com/2020/05/29/algorithm/exercise/question-min-num-of-stack/","excerpt":"经典算法题解-最小值栈 题目来源：最早是在念高中时看见这个题目的，具体来源已经不晓得了，网上流传了很多版本 题目难度：简单","text":"经典算法题解-最小值栈 题目来源：最早是在念高中时看见这个题目的，具体来源已经不晓得了，网上流传了很多版本 题目难度：简单 问题描述 问题很简单就一句话，实现一个带有最小值min()方法的栈，且要求耗时O(1) 问题分析 我是在高二暑假的一个训练营第一次看到这个问题的，这个问题属于那种“只有想不到，想到了就很容易”的问题。我当时拿到问题的第一个想法，就是在栈上设置一个min_value属性，但是很快问题就来了，如果这个min_value被栈pop了，这个属性就失效了，所以不可以单纯使用一个属性去记录。同样的问题要求时复为O(1)，所以也不可能将栈整个翻出来再找最小值 虽然设置属性不可行，但是重点已经出来了，对于栈这种单端数据操作的数据结构，需要设置一个记录型结构，存储每个状态下的min_value才行，比如栈内数据[2,7,6,3,1]的min=1，pop一次尾部后有[2,7,6,3]的min=2，这里其实自然而然想到辅助栈（栈本身就是一个记录型结构），在此给出方案A 1. 辅助栈 直接上图，对于入栈队列[3,2,7,6,1]，左侧为主栈，右侧为辅助栈，栈顶在上： 完整的元素变化流程如下： 观察右侧的辅助栈，其中每个元素都是对应左侧主栈中同层次-&gt;栈底的元素中的最小值，对主栈的读写会影响辅助栈的读写： 主栈push一个新元素a，辅助站将a与当前min比较，如a&lt;min，则辅助栈push a，否则辅助栈push min 主栈pop一个元素b，辅助栈跟随主栈，无条件pop一个元素c 辅助栈当前的栈顶元素就是主栈当前的最小值 Java的实例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940class AuxedStack &#123; // 分别设置主栈和辅助栈 private Stack&lt;Integer&gt; main; private Stack&lt;Integer&gt; aux; public AuxedStack() &#123; main = new Stack&lt;&gt;(); aux = new Stack&lt;&gt;(); &#125; // 和当前最小值比较，若小则辅助栈push新值，否则复制一次当前最小值 public void push(Integer i) &#123; main.push(i); if (aux.isEmpty() || i &lt; aux.peek()) &#123; aux.push(i); &#125; else &#123; aux.push(aux.peek()); &#125; &#125; // pop时主辅栈一起弹出 public Integer pop() &#123; aux.pop(); return main.pop(); &#125; // 辅助栈的顶元素就是当前最小值 public Integer min() &#123; return aux.peek(); &#125; // 其它的一些基本方法 public Integer peek() &#123; return main.peek(); &#125; boolean isEmpty() &#123; return main.isEmpty(); &#125; int size() &#123; return main.size(); &#125;&#125; 这里我图省事，就直接封装了JDK提供的Stack类 辅助栈其实还有优化空间，比如在本例给出的入栈序列[3,2,7,6,1]中，辅助栈为[1,2,2,2,3]，其中的2出现了3次，是可以压缩的，这里为了清楚展示代码没有这么处理 使用辅助栈的时间复杂度O(1)，空间为O(N) 2. 差异栈 辅助栈是一种不错的方案，但是会占据额外空间，似乎不是让人很满意，所以使用差异栈就成了另一种方案，差异栈在使用上不占额外空间。让我们把目光放回题目上，题目要求的是返回栈的最小值，且要求时耗是O(1)，其实这里很容易和栈本身的性质联系起来，栈顶元素的读写本身就是O(1)啊，所以出现了一个疑问，有没有什么方法可以把每个阶段的最小值放当时的栈顶？ 在这里介绍一下差异栈（下图右侧），在普通栈（下图左侧）中，每个节点存储的都是原始数据，但是差异栈在存储数据时会有额外处理，栈顶之外的元素存储的不是原始数据，而是和当时的栈顶元素的差值： 差异栈这种结构一开始只是为了方便记录地图上坐标之间的差值而设计的，结果后来发现了很多其它的作用，比如差异栈在本题中稍作变形即可，具体方案如下： 设置一个差异栈 允许同时操作栈的前两位 差异栈顶保存最小元素 push一个新元素，如果比当前栈顶元素小，则新元素成为新栈顶，原栈顶计算差值，成为第二元素；如果比当前栈顶大，则直接计算差值下压至第二位 pop时，直接越过栈顶元素看第二元素，如果第二元素小于零，说明本次pop的是最小元素（也就是栈顶元素本身），弹出栈顶元素，并还原差值，第二元素成为新栈顶；如果大于零，说明本次pop的是一个普通数值，还原差值后，直接弹出第二元素，栈顶保持不变（当前栈最小值不变） 依旧是入栈序列[3,2,7,6,1]，普通情况下的栈元素变化如下： 使用差异栈push情况下的栈元素变化（红色为新元素）： 使用差异栈pop情况下的栈元素变化（红色为出栈数据，比如在pop=6时，通过栈顶元素2+第二元素4，还原出原值6并弹出，然后最小值2不变，依旧在栈顶）： 这里给出相关的C++实现代码（比我用Java写的更清楚），如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#include &lt;memory.h&gt;#include &lt;stdio.h&gt;#include &lt;ostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;stdexcept&gt;#include &lt;stack&gt;using namespace std;template&lt;typename T&gt;class minStack&#123;public: T pop(); void push(const T&amp; elem); T min(); stack&lt;T&gt; s;&#125;;template&lt;typename T&gt;void minStack&lt;T&gt;::push(const T&amp;elem)&#123; if(s.empty()) &#123; s.push(elem); return; &#125; T minval = s.top(); s.pop(); s.push(elem-minval); if(elem &lt; minval) &#123; s.push(elem); &#125; else s.push(minval); return;&#125;template&lt;typename T&gt;T minStack&lt;T&gt;::pop()&#123; if(s.empty()) throw std::out_of_range(\"stack is empty\"); T minval = s.top(); s.pop(); T val = s.top(); s.pop(); if(val &lt;= 0) &#123; s.push(minval - val); val = minval; &#125; else &#123; s.push(minval); val = minval+val; &#125; return val;&#125;int main()&#123; return 0;&#125; 如果想看Java实例的在评论区戳我 使用差异栈不占用任何额外空间 一点碎碎念 这个是leetcode上一个老兄写的，原文在此[单变量标记当前最小元素解题](https://leetcode-cn.com/problems/min-stack-lcci/solution/dan-bian-liang-biao-ji-dang-qian-zui-xiao-yuan-su-/)，代码我就不贴了，原文链接里有，如果我没理解错的话，这个方案出来的图如下： 看完这个图基本就可以理解了，这种方案就是就是把压缩过长度的辅助栈融合到了主栈里，可以看到我在最右侧画的示意图，其实这就是一种变形了的双栈结构 两点碎碎念 在第一次接触差异栈的时候会觉得很奇怪，疑惑为什么要这么写，其实只要自己实现一次，就能很轻松理解其中的关系，差异值不是单纯的一个差值，它其实还表示了当前元素和栈顶元素（栈最小值的关系），这种关系的来源其实是上文辅助栈那张完整流程图中蓝色部分，也就是最小值滞留的体现，在未遇到比当前值还小的数值时，最小值是不变的，所以可以单纯用一个差值正负性来区别 下图是我们前文用过的双栈结构，其中左侧为主栈，主栈的每个栈元素就是数据本身，也就是每个栈元素只携带了一个信息（原始数值），但是对于差异栈来说，其中的每个栈元素也是一个数值，但其实携带了两个信息（原始数值和该数值与最小值的关系），所以我们可以用一个栈表示双栈法中需要两个栈才能表达的信息 这是双栈法： 这里对双栈结构加一点东西，看完这个图，各位应该心里有数了，差异栈是一个主从复合栈，本身在结构上，就同时拥有了主栈和辅助栈上存在的两类信息： 总结 时刻记住栈是一种记录型结构，以及差异栈这种特殊的栈变种，有时候可以在特定问题中发挥作用 如果你发现了bug，或者有自己的想法，请给博主发邮件，或者在评论区戳我，感谢阅读(′▽`〃) 参考 面试金典–MIN栈的实现","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"算法题解","slug":"算法/算法题解","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"习题","slug":"习题","permalink":"http://yoursite.com/tags/%E4%B9%A0%E9%A2%98/"}]},{"title":"经典算法题解-两数之和","slug":"algorithm/exercise/question-sum-of-two-numbers","date":"2020-05-29T09:00:00.000Z","updated":"2021-07-22T01:19:58.367Z","comments":true,"path":"2020/05/29/algorithm/exercise/question-sum-of-two-numbers/","link":"","permalink":"http://yoursite.com/2020/05/29/algorithm/exercise/question-sum-of-two-numbers/","excerpt":"经典算法题解-两数之和 题目来源：LeetCode-两数之和 题目难度：简单","text":"经典算法题解-两数之和 题目来源：LeetCode-两数之和 题目难度：简单 问题描述 给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍 示例： 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 问题分析 这个问题在理解上没有什么难点，主要就是给定一个数组和一个目标数target，其中每个元素至多使用一次，要求找到两个元素A和B，使得它们的和正好等于给定的target，返回这两个适格数字的下标。题目已经假定每个数组和target的组合只有有一个正确答案 题目很好理解，解法也很容易，直接双重for循环就可以解： 1. 双重for循环 直接看代码，这里给出Java的实现： 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; // 第一轮遍历 for (int i = 0; i &lt; nums.length; i++) &#123; // 第二轮遍历不能重复计算了 for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[i] + nums[j] == target) &#123; // 注意leetcode原题中要求返回的是索引位置 return new int[]&#123;i, j&#125;; &#125; &#125; &#125; return null; &#125;&#125; 时间复杂度O(N^2)，空间复杂度O(1) 上面这个双重for循环算法，先使用变量i遍历目标数组，然后对于每个元素，再追加遍历其位置至数组尾部的所有元素（因为之前的元素已经在i之前的遍历中比较过了），最终计算出相关位置。因为是双重for循环，所以很容易就可以计算出时间复杂度O(N^2)，空间复杂度O(1) 2. 字典遍历法 双重for循环虽然很容易想到，但是O(N^2)的时间代价明显不太行，所以考虑对其进行一些优化，对于优化，我们常见的策略有3种： 减少冗余计算 采用特殊数据结构 时间换空间 回到我们的题目上，假设有这么一个数组[6, 4, 1, 3, 7, 8, 9]，且目标数target=17，那我们可以发现，对于9之前的[6, 4, 1, 3, 7, 8]，其实每个数字在遍历时，都和9进行了一次比较，知道8+9=17才结束，这期间9其实被使用了6次，这明显是冗余了 所以我们希望有这么一个策略，在我们顺序遍历取得一个数num1的时候，就知道和它配对的数target-num1是否在我们的nums里面，并且不单单只存在一个。比如说target为4，nums为[2,3]，假设我们此时取得的num1为2，那么和它配对的2确实在nums中，但是数字2在nums中只出现了一次，我们无法取得两次，所以也是不行的。因此我们最终获得了以下步骤： 建立字典lookup存放第一个数字，并存放该数字的index 判断lookup中是否存在(target-当前数字cur)， 则当前值cur和某个lookup中的key值相加之和为target 如果存在，则返回：(target-当前数字cur)的index与当前值cur的index 如果不存在则将当前数字cur为key，当前数字的index为值存入lookup，继续计算下一个数 这里给出Java的示例代码： 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; // 将原本为两个目标值切换为一个目标值，只需要每次从 map 中寻找目标值即可 int num = target - nums[i]; if (map.containsKey(num)) &#123; return new int[]&#123;map.get(num), i&#125;; &#125; // 每次遍历过的值都存储到 map 中，这样之后就能从 map 中寻找需要的目标值 map.put(nums[i], i); &#125; return null; &#125;&#125; 时间复杂度O(N)，空间复杂度O(N) 这个算法改造，完整使用了我们上述3个改进策略，使用散列存储已经匹配过的结果，而且由于数据结构特性，散列表的读取都是O(1)（采用特殊数据结构），虽然读取快了，但是散列表本身会占据内存（时间换空间），采用散列之后，原本的双重for循环变成了一重（减少冗余计算），最终的时空复杂度均为O(N)，从代价上看明显小于原来的时间O(N^2) 一点碎碎念 上面这个图是我在一个前端群里看见的，图的作者原话是说自己的题解消耗有点大。稍微看一下代码，这个小老弟虽然只写了一层循环，乍一看代码还挺干净，但其实indexOf()方法本身也是一个遍历操作，所以在执行方面，这个其实还是一个双重for循环的做法，虽然本题非常简单，但是这个小老弟的写法还是提醒我们，在构建算法的时候，一定要小心局部的一些处理，很有可能随手一些，性能就打了折扣，尤其是构建一些复杂算法时，局部的细节处理一定要到位 总结 本题属于简单题，实现上很简单，本篇也给出了对应的Java代码实例，同时一个老兄的代码给我们提了个醒，性能的折扣很有可能出现在一些微小的地方。唯一需要注意的是，在考虑给算法优化的时候，最基本的3点策略还是： 减少冗余计算 采用特殊数据结构 时间换空间 如果你发现了bug，或者有自己的想法，请给博主发邮件，或者在评论区戳我，感谢阅读(′▽`〃)","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"算法题解","slug":"算法/算法题解","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"习题","slug":"习题","permalink":"http://yoursite.com/tags/%E4%B9%A0%E9%A2%98/"}]},{"title":"经典算法题解-汉诺塔","slug":"algorithm/exercise/question-recursion-hanoi","date":"2020-04-16T06:00:21.000Z","updated":"2021-07-22T01:19:58.366Z","comments":true,"path":"2020/04/16/algorithm/exercise/question-recursion-hanoi/","link":"","permalink":"http://yoursite.com/2020/04/16/algorithm/exercise/question-recursion-hanoi/","excerpt":"递归算法实现汉诺塔","text":"递归算法实现汉诺塔 代码实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.blade.exercise.recursion.hanoi;import java.util.Stack;public class App &#123; private static Integer callCount = 0; // 空间复杂度计数器 private static Integer moveCount = 0; // 时间复杂度计数器 /** * 把from栈上n个元素移植到to栈上 * 从src上的n个元素中，取出n-1移动到aux上 */ private static void move(Stack&lt;Integer&gt; src, Stack&lt;Integer&gt; des, Stack&lt;Integer&gt; aux, Integer num) &#123; // 计数器和日志型输出 callCount++; System.out.println(\"move \"+(num)+\" elements form src.\"+ src +\" to des.\" + des + \" with aux.\" + aux); if (num == 1) &#123; moveCount++; des.push(src.pop()); &#125; else &#123; // 递归核心，大问题依赖小问题的解决，会有空间延伸 move(src, aux, des, num-1); // 移动n-1的上层建筑到辅助柱 move(src, des, aux, 1); // 移动底盘到目标柱 move(aux, des, src, num-1); // 移动n-1的上层建筑回到目标柱上的底盘上 &#125; &#125; public static void main(String[] args) &#123; Stack&lt;Integer&gt; src = new Stack&lt;&gt;(); Stack&lt;Integer&gt; aux = new Stack&lt;&gt;(); Stack&lt;Integer&gt; des = new Stack&lt;&gt;(); src.push(5); src.push(4); src.push(3); src.push(2); src.push(1); System.out.println(\"src stack: \" + src + \"\\ndes stack: \" + des +\"\\naux stack: \" + aux); System.out.println(\"********************* Start To Move Elements **********************\"); move(src, des, aux, src.size()); System.out.println(\"********************* Stop To Move Elements **********************\"); System.out.println(\"total call count: \" + callCount + \" times\"); System.out.println(\"total move count: \" + moveCount + \" times, equals to -1+2^n\"); System.out.println(\"src stack: \" + src + \"\\ndes stack: \" + des +\"\\naux stack: \" + aux); &#125;&#125; 代码中的日志型输出可以一律清除","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"算法题解","slug":"算法/算法题解","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","permalink":"http://yoursite.com/tags/%E9%80%92%E5%BD%92/"}]},{"title":"JdbcTemplate使用和源码解析初步","slug":"java/spring/spring-learn-jebctemplate-src","date":"2020-04-11T13:35:09.000Z","updated":"2021-07-22T01:19:58.371Z","comments":true,"path":"2020/04/11/java/spring/spring-learn-jebctemplate-src/","link":"","permalink":"http://yoursite.com/2020/04/11/java/spring/spring-learn-jebctemplate-src/","excerpt":"JdbcTemplate源码解析初步 本文会从JdbcTemplate的使用开始，一步一步直到讲解完JdbcTemplate的核心流程，本文不是所谓的”文档型博客“，也不会讲解所有的类和接口，而是希望讲清楚核心流程，从而掌握JdbcTemplate的设计理念和设计模式，从而在工作中更好地掌握Jdbc和写出自己的JdbcUtils工具。文章包含有一下内容： JdbcTemplate的基本使用 构建Template的核心模式–模板模式 JdbcTemplate的核心流程源码 JdbcTemplate的几个组件类源码 本文有一点点长，请耐心阅读","text":"JdbcTemplate源码解析初步 本文会从JdbcTemplate的使用开始，一步一步直到讲解完JdbcTemplate的核心流程，本文不是所谓的”文档型博客“，也不会讲解所有的类和接口，而是希望讲清楚核心流程，从而掌握JdbcTemplate的设计理念和设计模式，从而在工作中更好地掌握Jdbc和写出自己的JdbcUtils工具。文章包含有一下内容： JdbcTemplate的基本使用 构建Template的核心模式–模板模式 JdbcTemplate的核心流程源码 JdbcTemplate的几个组件类源码 本文有一点点长，请耐心阅读 什么是JdbcTemplate JdbcTemplate是Spring-Jdbc包下的一个主要操作类，Spring-Jdbc包则是Spring框架生态中专门用于封装Jdbc的一系列类和接口，但是在实际使用中，涉及数据库事务的操作必须配合Spring-tx包（用于事务管理）使用，一个完整的执行JdbcTemplate的maven依赖如下： 1234567891011121314&lt;dependencies&gt; &lt;!-- 事务管理 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JdbcTemplate --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 本文出现的所有代码均以5.2.5.RELEASE的版本为例 由于tx的完整使用使用需要aop，本文只讨论JdbcTemplate，其它博文中会讨论tx 使用JdbcTemplate的几个例子 在开始研究源码之前，先看一下JdbcTemplate在调用方是怎么使用的，好对JdbcTemplate有一个大概的了解 0. 开始之前 在本文的示例中，我们手动创建一个JdbcTemplate实例，在实际的Spring环境下，应当由IOC容器来提供。JdbcTemplate实例化的必要条件只有一个，那就是拥有一个DataSource实例： 123456789public class JdbcTemplate extends JdbcAccessor implements JdbcOperations &#123; // ... // 源码第164行至167行的携带数据源的构造器签名 public JdbcTemplate(DataSource dataSource) &#123; setDataSource(dataSource); afterPropertiesSet(); &#125; // ...&#125; 这里咱图省事，直接用C3P0来做数据库连接池，实现DataSource接口，C3P0的主类ComboPooledDataSource在实例化时若未制定配置文件会主动扫描classpath下的c3p0-config.xml，这里偷懒就直接让它默认扫描了： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- 一个简化版的c3p0-config.xml --&gt;&lt;c3p0-config&gt; &lt;default-config&gt; &lt;!-- 连接四大参数配置 --&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://127.0.0.1:3306/jdbc?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=UTC&lt;/property&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;root&lt;/property&gt; &lt;!-- 池参数配置 --&gt; &lt;property name=\"acquireIncrement\"&gt;3&lt;/property&gt; &lt;property name=\"initialPoolSize\"&gt;10&lt;/property&gt; &lt;property name=\"minPoolSize\"&gt;2&lt;/property&gt; &lt;property name=\"maxPoolSize\"&gt;10&lt;/property&gt; &lt;/default-config&gt;&lt;/c3p0-config&gt; 然后调用一下代码，就可以快速获得一个JdbcTemplate实例了，ComboPooledDataSource会自动扫描classpath下的c3p0-config.xml并实例化一个DataSource给JdbcTemplate： 123456public class TestTemplate &#123; private static void testJdbc() &#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(new ComboPooledDataSource()); // ... &#125;&#125; 1. 使用update()修改数据 和Jdbc中的executeUpdate()方法一样，JdbcTemplate的update()方法可用于 增/删/改，且返回值为影响了的数据库的行数： 1234JdbcTemplate jdbcTemplate = new JdbcTemplate(new ComboPooledDataSource());String sql = \"update t_user set password = ? where uid = ?\";int count = jdbcTemplate.update(sql, \"default\", 10001);System.out.println(\"has updated \" + count + \" rows\"); 2. 使用query()查询行，并映射哈希组 使用使用query()查询行，并指定一个映射规则RowMapper，将二位表的结果映射到List&lt;Map&lt;String, Object&gt;&gt;的数据容器对象中： 12345678// 无参数版本String sql = \"select * from t_user\";RowMapper&lt;Map&lt;String, Object&gt;&gt; rowMapper = new ColumnMapRowMapper();List&lt;Map&lt;String, Object&gt;&gt; rows = jdbcTemplate.query(sql, rowMapper);// 有参数版本sql = \"select * from t_user where uid &gt; ? and uid &lt; ?\";RowMapper&lt;Map&lt;String, Object&gt;&gt; rowMapper = new ColumnMapRowMapper();List&lt;Map&lt;String, Object&gt;&gt; rows = jdbcTemplate.query(sql, rowMapper, 10001, 10010); 不手动指定映射规则，而采用JdbcTemplate封装好的queryForList()方法，结果和上面使用RowMapper的代码是一致的： 12String sql = \"select * from t_user where uid &gt; ? and uid &lt; ?\";List&lt;Map&lt;String, Object&gt;&gt; rows = jdbcTemplate.queryForList(sql, 10001, 10010); 后面我们会看见这两个方法其实是一样的 3. 使用query()查询行，并映射实体类 JdbcTemplate提供了3种映射规则，除了上文映射哈希组的ColumnMapRowMapper，还有SingleColumnRowMapper和BeanPropertyRowMapper，使用前者可以映射类似count(*)这样的单行，后者则可以将结果集映射到一个实体类上面，非常方便： 12345678// 映射单行String sql = \"select uid from t_user where uid &gt; ? and uid &lt; ?\";RowMapper&lt;Integer&gt; rowMapper = new SingleColumnRowMapper(Integer.class);List&lt;Integer&gt; uids = jdbcTemplate.query(sql,rowMapper, 10001,10010);// 映射实体String sql = \"select * from t_user where uid &gt; ? and uid &lt; ?\";RowMapper&lt;User&gt; rowMapper = new BeanPropertyRowMapper&lt;User&gt;(User.class);List&lt;User&gt; users = jdbcTemplate.query(sql,rowMapper, 10001,10010); 使用BeanPropertyRowMapper，表字段命名需跟实体类属性一致，或者是下划线对应驼峰 通过以上3个基本例子，对JdbcTemplate的使用已经有了基本的了解，流程也很固定，手写sql，丢进JdbcTemplate提供的查询方法，并获取一个处理过的结果。对我来说，JdbcTemplate给我的第一感觉，就是个执行器+映射器，总体特征有点像Mybatis的Executor，后来读了源码，发现也确实如此 模板模式 在我们真正掀开JdbcTemplate的裙子，看看里面有什么大宝贝前，还需要了解一个行为型设计模式，模板模式。JdbcTemplate就是基于模板模式做到的抽象和层次剥离 1. 15分钟模板模式火箭式入门 一句话解释就是“老爹画图的线条，儿子填色，最终变成一副完整的画”。OOP的基本释义为，为子类设计一个模板，以便在子类中可以复用这些方法。完整定义如下： 定义一个操作中的算法的框架，由父类控制着算法的主要流程，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤 总言之，父类始终控制着整个流程的主动权，子类只是辅助（或者说配合）父类实现某些可定制的步骤 模板模式的常见实现有2种： 基于抽象类的实现 基于回调的实现 本质依旧是Java的面向接口编程和约定式编程 1. 基于抽象类的模板模式 在抽象类中定义一个算法流程，将部分细节封装成抽象方法，强制子类实现，从而实现不同情况不同实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 抽象模板public abstract class AbstractTemplate &#123; // 模板方法 public void templateMethod() &#123; //（所有）基本方法，在这里构成了模板方法的主体逻辑（主体执行算法） // 基本方法根据职能也可以有不同的分类，常见有抽象方法，钩子方法（插件，比如引入一个日志钩子）和具体方法 abstractMethod(); hookMethod(); concreteMethod(); &#125; // 抽象方法，必须有子类实现 protected abstract void abstractMethod(); // 钩子方法，子类可以选择重写或不重写 protected void hookMethod() &#123; &#125; // 具体方法，通常携带final关键字，子类不可修改 private final void concreteMethod() &#123; System.out.println(\"抽象类中的具体方法\"); &#125;&#125;// 由子类实现所有的抽象方法，使得类完整可执行// A实现public class ConcreteTemplateA extends AbstractTemplate &#123; protected void abstractMethod() &#123; System.out.println(\"A 子类中重写的抽象方法\"); &#125;&#125;// B实现public class ConcreteTemplateB extends AbstractTemplate &#123; protected void abstractMethod() &#123; System.out.println(\"B 子类中重写的抽象方法\"); &#125;&#125;// 测试用例public class Client &#123; public static void main(String[] args) &#123; AbstractTemplate tp = new ConcreteTemplateA(); // 调用子类 A 的模板方法 tp.templateMethod(); tp = new ConcreteTemplateB(); // 调用子类 B 的模板方法 tp.templateMethod(); &#125;&#125; 2. 基于回调的模板模式 之前基于抽象类的木板模式固然不错，但是有一个问题，当父类中出现了10个抽象方法时，子类就必须把这10个方法全部实现，但是子类所需要运行的那部分逻辑可能之需要其中3个方法，那这就造成了浪费，所以就出现了新的实现，基于回调的实现，在父类中定义若干个接口，子类按需进行实现，在调用时把自己实现的回调对象注入回父类，完成模板模式的细节填充 一个典型的回调过程： 什么是回调函数，简单来说，就是A类定义了a()和callback()，并在a()中调用了B类的b()方法，但是b()方法在执行时反过来调用了A.a()，这种模式类似委托人，你（A类）将自己买的枪（callback方法）交给了一名职业杀手（B类），并委托（执行a方法）杀手杀人（执行b方法），而且杀手为了不暴露自己，用的是你的枪（callback方法，由A.a()中的调用参数注入给B.b()）,杀手只执行自己的业务（杀人，也就是b()）。在这个案例中，你作为委托人是具体的（具体子类），拥有真实资源（枪）和发起委托的权利，而杀手是抽象的（抽象父类），只要准备了杀手要求提供的武器，谁都能去委托他杀人（b()方法，杀人业务），但他用的其实是你的枪。在回调过程中，callback的拥有者是A，但执行者是B，A调用了B，却被B反过来调用了A的资源，这个过程称回调 委托杀手杀人的回调过程： 1234567891011121314151617181920212223242526272829303132// 武器接口public interface Weapon &#123; void kill(String name);&#125;// 委托人public class Delegater &#123; // 买了一把枪 Weapon gun = new Weapon() &#123; public void kill(String name) &#123; System.out.println(\"一枪打死了\" + name); &#125; &#125;; // 把枪交给杀手，委托杀手杀人 void delegateKiller() &#123; new Killer().killSomebody(gun, \"你的项目经理\"); &#125;&#125;// 杀手public class Killer &#123; // 杀手的抽象业务，按照委托人给的武器和名单杀人 public void killSomebody(Weapon weapon, String name) &#123; System.out.print(\"杀手\"); weapon.kill(name); &#125;&#125;// 测试类public class Client &#123; public static void main(String[] args) &#123; new Delegater().delegateKiller(); // 输出：杀手一枪打死了你的项目经理 &#125;&#125; 在这个例子中，杀手就是抽象父类，委托人就是具体子类，通过回调过程，自然而然地实现了模板模式 3. JdbcTemplate为什么采用基于回调的模板模式 为什么要用模板模式 这是一段传统且完整的Jdbc代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TestJdbc &#123; // 定义常量 private static String DriverClassName = \"com.mysql.cj.jdbc.Driver\"; private static String Url = \"jdbc:mysql://127.0.0.1:3306/jdbc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true\"; private static String username = \"root\"; private static String password = \"root\"; public static void main(String[] args) &#123; Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; String sql = \"select * from t_user where uid &gt; ?\"; try &#123; // 1.注册数据库驱动 Class.forName(DriverClassName); // 2.获取连接 connection = DriverManager.getConnection(Url, username, password); // 3.控制事务 connection.setAutoCommit(false); // 4.准备语句，绑定参数 preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1, 100); // 5.解析结果集，映射对象或封装map resultSet = preparedStatement.executeQuery(); while (resultSet.next()) &#123; System.out.print(\"the uid is: \"+resultSet.getObject(1)); &#125; &#125; catch (ClassNotFoundException e) &#123; // 6.异常处理 e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 7.关闭废弃连接 try &#123; if (resultSet != null) &#123; resultSet.close(); &#125; if (preparedStatement != null) &#123; preparedStatement.close(); &#125; if (connection != null) &#123; connection.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 在这个代码中，一共有7个主要步骤，但是只有4的准备语句和5的解析结果集是不一样的，其它步骤在另一个Jdbc代码中是重复，这就很明显了，可以制作一个Jdbc父类模板，由模板控制获取连接和异常处理一类的代码，剩下由子类提交自己的语句和结果映射规则，做到代码复用，调试起来也更加方便，这个就是JdbcTemplate的核心思想 为什么要用回调实现模板模式 前文提过了，是为了规避抽象类中抽象方法过多的问题 JdbcTemplate核心流程源码 在看了前文这么多废话后，终于开始源码部分了，达瓦里西完全可以自己打开ide去看，idea中Ctrl+B就可以回溯代码 1. JdbcTemplate几个核心签名 JdbcTemplate和我们通常用的静态JdbcUtils不一样，它是一个类，可以被实例化： 12345678910111213141516// 这是一个常见的核心类构造过程：接口（定义所有的核心方法）-&gt;抽象类（实现大部分的工具方法）-&gt;类（完整实现）public class JdbcTemplate extends JdbcAccessor implements JdbcOperations &#123; public JdbcTemplate() &#123;&#125; // 前文提过，构造JdbcTemplate实例必须有DataSource public JdbcTemplate(DataSource dataSource) &#123; // setDataSource()是在JdbcAccessor中实现的，用于将ds绑定到一个本地变量上 setDataSource(dataSource); // setDataSource()也由JdbcAccessor实现，作用是校验datasource是否已经绑定，如果null则抛IllegalArgumentException afterPropertiesSet(); &#125; public JdbcTemplate(DataSource dataSource, boolean lazyInit) &#123; setDataSource(dataSource); setLazyInit(lazyInit); afterPropertiesSet(); &#125;&#125; 施工ing","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"Spring","slug":"Java/Spring","permalink":"http://yoursite.com/categories/Java/Spring/"},{"name":"Spring-JDBC","slug":"Java/Spring/Spring-JDBC","permalink":"http://yoursite.com/categories/Java/Spring/Spring-JDBC/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"},{"name":"jdbc","slug":"jdbc","permalink":"http://yoursite.com/tags/jdbc/"}]},{"title":"CSS小积木-Font Awesome的正确使用方法","slug":"css-building-blocks/cbb-correct-use-of-fa","date":"2020-03-22T17:12:49.000Z","updated":"2021-07-22T01:19:58.368Z","comments":true,"path":"2020/03/23/css-building-blocks/cbb-correct-use-of-fa/","link":"","permalink":"http://yoursite.com/2020/03/23/css-building-blocks/cbb-correct-use-of-fa/","excerpt":"通过重现css更有效地使用Font Awesome 引言 其实这回当了标题党，本文讨论的是通过自己实现css来局部加载Font Awesome字体图标，Font Awesome就不用说了，简称fa，非常流行的字体图标库，但是说实在话，font-awesome.css压缩完了也有30KB，不能算小了，有时只用几个图标，却要把上千个图标全部引进来，真的不是很环保（笑），所以我们通过重现Font Awesome的css流程（其实是闲得蛋疼），写一个简化的font-awesome来做到按需加载。到后面我们也会发现其原理也很简单，收拾完了就一字体组，每个字都有一个编号，我们之后就会认识到Font Awesome其实就是字体","text":"通过重现css更有效地使用Font Awesome 引言 其实这回当了标题党，本文讨论的是通过自己实现css来局部加载Font Awesome字体图标，Font Awesome就不用说了，简称fa，非常流行的字体图标库，但是说实在话，font-awesome.css压缩完了也有30KB，不能算小了，有时只用几个图标，却要把上千个图标全部引进来，真的不是很环保（笑），所以我们通过重现Font Awesome的css流程（其实是闲得蛋疼），写一个简化的font-awesome来做到按需加载。到后面我们也会发现其原理也很简单，收拾完了就一字体组，每个字都有一个编号，我们之后就会认识到Font Awesome其实就是字体 Font Awesome到底干了什么 我手头的font-awesome.css版本是4.7.0，让我们掀开fa的裙子看看里面到底有什么大宝贝 一段使用fa的典型html骨架： 1&lt;i class=\"fa fa-music\"&gt;&lt;/i&gt; 翻看font-awesome.css源码的第7行到21行： 以及183行到197行的一众fa-xxx类实现： 看到这里我们就基本明白了fa的实现流程了，fa将自己打包的字体封装成一个字体族FontAwesome（源码第8行），需要使用fa的html元素使用这个封装好的字体（源码第16行），如此设置过后，就可以在.fa元素里使用字符编码来显示对应的字体图标了。如此不难看出，字体图标本体其实就是一个数字文本 重现样式 既然知道了实现流程，那我们就可以复现这一过程来创建自己的字体库 1. 获取Font Awesome 首先就是下载Font Awesome，官网下也好，npm也好，我这里直接从npm下载了： 1$ npm install font-awesome --save 要下完整包，不是单个的压缩过的css文件，因为我们之后需要其中的font文件 2. 导入fa的字体 在fa的文件夹中找到对应的字体文件，也就是font文件夹下的6个文件，复制我们的项目中: 在css文件中，使用这些字体文件创建我们自己的font-family： 1234567891011@font-face &#123; font-family: 'FontAwesome'; src: url('fonts/fontawesome-webfont.eot?v=4.7.0'); src: url('fonts/fontawesome-webfont.eot?#iefix&amp;v=4.7.0') format('embedded-opentype'), url('fonts/fontawesome-webfont.woff2?v=4.7.0') format('woff2'), url('fonts/fontawesome-webfont.woff?v=4.7.0') format('woff'), url('fonts/fontawesome-webfont.ttf?v=4.7.0') format('truetype'), url('fonts/fontawesome-webfont.svg?v=4.7.0#fontawesomeregular') format('svg'); font-weight: normal; font-style: normal;&#125; 注意修改正确的路径 3. 查找图标代码 比如我们需要使用fa-code这个字体，那我们就到font-awesome.css文件中查找对应的代码： 1234/* 在font-awesome.css-4.7.0的985行找到了这个字体图标的代码，\\f121就是我们的图标编号 */.fa-code:before &#123; content: \"\\f121\";&#125; 4. 创建样式 获取到代码后就可以创建我们自己的字体样式了，很简单，使用之前用fa字体创建的font-family就行，只要一行： 123.icon &#123; font-family: FontAwesome,serif;&#125; 在代码中引用我们自己的字体图标也很简单，只需稍微修改一下前缀，实例如下： 12/* \\f121对应的html转义是&amp;#xf121 */&lt;span class=\"icon\"&gt;&amp;#xf121&lt;/span&gt; 效果如下（有点小，因为还没有任何额外样式）： 至此我们自己实现的简单的Font Awesome就完成了，现在按需加载相关图标，减少了传输体积，但是font文件还是没变，如果你够猛也可以自己裁剪字体文件手绘svg，进一步减少体积 使用我们的字体库 通过之前的操作我们已经完成了一个简单的fa，但是离实际使用还是有些差距的，比如没有fa-spin来提供旋转效果，所以用之前需要完善一下代码，但我们其实已经可以知道，fa本质就是字体，字体图标本质就是文本，所以我们很轻松就可以写出一些功能和效果，类似这么一个移动布局中常见的提示图案： 在之前的基础上再稍加一些代码就可，完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// style.css@font-face &#123; font-family: 'FontAwesome'; src: url('fonts/fontawesome-webfont.eot?v=4.7.0'); src: url('fonts/fontawesome-webfont.eot?#iefix&amp;v=4.7.0') format('embedded-opentype'), url('fonts/fontawesome-webfont.woff2?v=4.7.0') format('woff2'), url('fonts/fontawesome-webfont.woff?v=4.7.0') format('woff'), url('fonts/fontawesome-webfont.ttf?v=4.7.0') format('truetype'), url('fonts/fontawesome-webfont.svg?v=4.7.0#fontawesomeregular') format('svg'); font-weight: normal; font-style: normal;&#125;.icon &#123; font-family: FontAwesome,serif; display: inline-block; text-align: center;&#125;.icon-check &#123; display: block; margin: 0 auto; width: 6rem; height: 6rem; line-height: 6rem; font-size: 3.5rem; border-radius: 50%; background: #09BB07; color: #fff;&#125;#container &#123; position: absolute; top: 50%; transform: translateY(-50%); width: 100%;&#125;.check-message &#123; font-family: \"Lucida Sans\", Verdana, Arial, sans-serif; font-weight: 600; font-size: 1.5rem; color: #555555; text-align: center;&#125; 1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;test-icon&lt;/title&gt; &lt;!-- 导入样式 --&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"container\"&gt; &lt;!-- 使用字体图标 --&gt; &lt;span class=\"icon icon-check\"&gt;&amp;#xf00c&lt;/span&gt; &lt;p class=\"check-message\"&gt;提交成功&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 时刻注意，字体图标的本质始终是文字 总结 在本文中我们简单复现了fa，想看完整案例的旁友可以戳我的仓库css-building-blocks，如果你发现了问题或者有自己的想法，可以提issue或者在评论区戳我","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"CSS小积木","slug":"前端/CSS/CSS小积木","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/CSS/CSS%E5%B0%8F%E7%A7%AF%E6%9C%A8/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"解决Node报错 System limit for number of file watchers reached","slug":"linux/solution-for-kde-node-watch-limit-error","date":"2020-03-21T07:27:40.000Z","updated":"2021-07-22T01:19:58.372Z","comments":true,"path":"2020/03/21/linux/solution-for-kde-node-watch-limit-error/","link":"","permalink":"http://yoursite.com/2020/03/21/linux/solution-for-kde-node-watch-limit-error/","excerpt":"解决 Error: ENOSPC: System limit for number of file watchers reached 问题场景 最近突发奇想想写一个小例子，为了图省事直接用browser-sync做了个小服务器，用了简单粗暴的一条命令： 1$ browser-sync start --server --files \"**\" 这条命令以前一直没什么问题，我的系统是Manjaro Kde Plasma 19.0.2，报了一个奇奇怪怪的错误Error: ENOSPC: System limit for number of file watchers reached，完整输入如下：","text":"解决 Error: ENOSPC: System limit for number of file watchers reached 问题场景 最近突发奇想想写一个小例子，为了图省事直接用browser-sync做了个小服务器，用了简单粗暴的一条命令： 1$ browser-sync start --server --files \"**\" 这条命令以前一直没什么问题，我的系统是Manjaro Kde Plasma 19.0.2，报了一个奇奇怪怪的错误Error: ENOSPC: System limit for number of file watchers reached，完整输入如下： 1234567891011121314151617181920212223242526272829303132333435[Browsersync] Access URLs: ------------------------------------- Local: http://localhost:3000 External: http://192.168.1.10:3000 ------------------------------------- UI: http://localhost:3001 UI External: http://localhost:3001 -------------------------------------[Browsersync] Serving files from: ./[Browsersync] Watching files...events.js:293 throw er; // Unhandled 'error' event ^Error: ENOSPC: System limit for number of file watchers reached, watch '/home/blade/桌面/github-project/j2ee-demo/chapter01/message-board/node_modules/rxjs/observable/SubscribeOnObservable.js.map' at FSWatcher.&lt;computed&gt; (internal/fs/watchers.js:169:26) at Object.watch (fs.js:1366:34) at createFsWatchInstance (/home/blade/桌面/github-project/j2ee-demo/chapter01/message-board/node_modules/chokidar/lib/nodefs-handler.js:38:15) at setFsWatchListener (/home/blade/桌面/github-project/j2ee-demo/chapter01/message-board/node_modules/chokidar/lib/nodefs-handler.js:81:15) at FSWatcher.NodeFsHandler._watchWithNodeFs (/home/blade/桌面/github-project/j2ee-demo/chapter01/message-board/node_modules/chokidar/lib/nodefs-handler.js:233:14) at FSWatcher.NodeFsHandler._handleFile (/home/blade/桌面/github-project/j2ee-demo/chapter01/message-board/node_modules/chokidar/lib/nodefs-handler.js:262:21) at FSWatcher.&lt;anonymous&gt; (/home/blade/桌面/github-project/j2ee-demo/chapter01/message-board/node_modules/chokidar/lib/nodefs-handler.js:495:21) at FSReqCallback.oncomplete (fs.js:171:5)Emitted 'error' event on FSWatcher instance at: at FSWatcher._handleError (/home/blade/桌面/github-project/j2ee-demo/chapter01/message-board/node_modules/chokidar/index.js:260:10) at createFsWatchInstance (/home/blade/桌面/github-project/j2ee-demo/chapter01/message-board/node_modules/chokidar/lib/nodefs-handler.js:40:5) at setFsWatchListener (/home/blade/桌面/github-project/j2ee-demo/chapter01/message-board/node_modules/chokidar/lib/nodefs-handler.js:81:15) [... lines matching original stack trace ...] at FSReqCallback.oncomplete (fs.js:171:5) &#123; errno: -28, syscall: 'watch', code: 'ENOSPC', path: '/home/blade/桌面/github-project/j2ee-demo/chapter01/message-board/node_modules/rxjs/observable/SubscribeOnObservable.js.map', filename: '/home/blade/桌面/github-project/j2ee-demo/chapter01/message-board/node_modules/rxjs/observable/SubscribeOnObservable.js.map'&#125; 问题解决 从报错的字面看，是操作系统限制了node脚本运行监视的文件数目，本着“99%的计算机问题都有前辈解决过”原则，直接把报错丢上stackoverflow.com，然后找到了这篇metro-bundler-ready-error-enospc-system-limit-for-number-of-file-watchers-reac，按照前辈们踩坑之路顺利解决了 1234// 应该存在一个/etc/sysctl.d/50-max_user_watches.conf的文件$ cd /etc/sysctl.d $ cat 50-max_user_watches.conf fs.inotify.max_user_watches = 16384 用vim将限制数16384修改成524288后，启用修改： 12$ sudo sysctl -p$ sudo sysctl --system 总结 从问题上看是简单粗暴用browser-sync监视了所有文件导致的，我这里应该是把node_modules/中的文件也纳入监视了，导致监视数爆了，除了修改50-max_user_watches.conf，其实简单修改一下sync命令也可以，只监控需要参与变动的文件： 1$ browser-sync start --server --files \"dist/**, pages/**\"","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"踩坑日常","slug":"Linux/踩坑日常","permalink":"http://yoursite.com/categories/Linux/%E8%B8%A9%E5%9D%91%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"manjaro kde plasma","slug":"manjaro-kde-plasma","permalink":"http://yoursite.com/tags/manjaro-kde-plasma/"}]},{"title":"CSS小积木-表格构建的日历表","slug":"css-building-blocks/cbb-table-based-calendar","date":"2020-03-19T08:04:57.000Z","updated":"2021-07-22T01:19:58.368Z","comments":true,"path":"2020/03/19/css-building-blocks/cbb-table-based-calendar/","link":"","permalink":"http://yoursite.com/2020/03/19/css-building-blocks/cbb-table-based-calendar/","excerpt":"CSS小积木-基于表格元素创建一个日历表 构建日历表 日历表是一个非常常见的前端组建，无论是在博客系统中还是后台管理系统中都非常有用，尤其是在系统文章过多时，日历表配合时间线可以很好组织历史信息。本文使用&lt;table&gt;作为日历表的html骨架，在实际应用中自然可以使用div堆叠或者其它结构，但是&lt;table&gt;的可读性是最佳的","text":"CSS小积木-基于表格元素创建一个日历表 构建日历表 日历表是一个非常常见的前端组建，无论是在博客系统中还是后台管理系统中都非常有用，尤其是在系统文章过多时，日历表配合时间线可以很好组织历史信息。本文使用&lt;table&gt;作为日历表的html骨架，在实际应用中自然可以使用div堆叠或者其它结构，但是&lt;table&gt;的可读性是最佳的 表格的基础HTML结构 123456789101112&lt;table id=\"tab\"&gt; &lt;tr&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;age&lt;/th&gt; &lt;th&gt;sex&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;xuezhijian&lt;/td&gt; &lt;td&gt;22&lt;/td&gt; &lt;td&gt;male&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表格元素的可选项： &lt;caption&gt;：表题是可选的，经常用于显示当前信息 &lt;thead&gt;&lt;tbody&gt;&lt;tfoot&gt;：是语义标签，没有实意，其中&lt;tfoot&gt;会被放到表格最底层 &lt;col&gt;和&lt;colgroup&gt;：用于约束一整列元素，属于“替身使者”，作用在某一个&lt;col&gt;上的元素会被应用到整列 表格专用的样式： border-collapse：用于控制表格的单元格之间的空隙，建议设为collapse table-layout：控制单元格向第一行看齐，设置fixed使得表格第一行申明的列宽具有绝对性，后续行如遇内容过多，只能折行或者溢出 日历表的设计 百度日历 原始日历表 观察百度日历的样式，得出以下可以改进设计的地方： 醒目的表头：表头应该有独立样式，且用横线（如border-bottom）来和表体隔开，而且在职能上应该有更多的信息（如配合js显示为当前日期） 表的尺寸：不可以挤满整行，影响观感，设置max-width 单元格的尺寸：原始表的单元格过于拥挤，要设置合理的宽高，来使得单元格更加饱满，方便显示其中的数据。而且单元格缺少边框之类的视觉参照物 好看的字体：字体好看很重要，同时去掉下划线 染色：今天，周末，非本月，都要有单独的染色 源码收录-日历表 html骨架代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;table class=\"cal\"&gt; &lt;caption&gt;&lt;strong&gt;January&lt;/strong&gt; 2015&lt;/caption&gt; &lt;colgroup&gt; &lt;col class=\"cal-mon\"&gt; &lt;col class=\"cal-tue\"&gt; &lt;col class=\"cal-wed\"&gt; &lt;col class=\"cal-thu\"&gt; &lt;col class=\"cal-fri\"&gt; &lt;col class=\"cal-sat cal-weekend\"&gt;&lt;!-- 应用在col上的样式会映射到整列上 --&gt; &lt;col class=\"cal-sun cal-weekend\"&gt;&lt;!-- 是很方便的操作 --&gt; &lt;/colgroup&gt; &lt;thead&gt; &lt;tr&gt; &lt;th scope=\"col\"&gt;Mon&lt;/th&gt; &lt;th scope=\"col\"&gt;Tue&lt;/th&gt; &lt;th scope=\"col\"&gt;Wed&lt;/th&gt; &lt;th scope=\"col\"&gt;Thu&lt;/th&gt; &lt;th scope=\"col\"&gt;Fri&lt;/th&gt; &lt;th scope=\"col\"&gt;Sat&lt;/th&gt; &lt;th scope=\"col\"&gt;Sun&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class=\"cal-inactive\"&gt;29&lt;/td&gt;&lt;!-- 非本月的日子要用淡色染色 --&gt; &lt;td class=\"cal-inactive\"&gt;30&lt;/td&gt;&lt;!-- 而且鼠标要设置disabled --&gt; &lt;td class=\"cal-inactive\"&gt;31&lt;/td&gt;&lt;!-- 在html上也去掉&lt;a&gt; --&gt; &lt;td&gt;&lt;a href=\"#\"&gt;1&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;2&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;3&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;4&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;a href=\"#\"&gt;5&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;6&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;7&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;8&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;9&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;10&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;11&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;a href=\"#\"&gt;12&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;13&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;14&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;15&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;16&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;17&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;18&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;a href=\"#\"&gt;19&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;20&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;21&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;22&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;23&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;24&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;25&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;a href=\"#\"&gt;26&lt;/a&gt;&lt;/td&gt; &lt;td class=\"cal-current\"&gt;&lt;a href=\"#\"&gt;27&lt;/a&gt;&lt;/td&gt;&lt;!-- 当前日子需要特殊染色，而且是最醒目的 --&gt; &lt;td&gt;&lt;a href=\"#\"&gt;28&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;29&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;30&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\"&gt;31&lt;/a&gt;&lt;/td&gt; &lt;td class=\"cal-inactive\"&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 样式代码收录： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.cal &#123; border-collapse: collapse; table-layout: fixed; width: 100%; max-width: 25em; font-family: \"Lucida Grande\", Verdana, Arial, \"Helvetica Neue\", Helvetica, sans-serif; text-align: center;&#125;.cal caption &#123; text-align: left; border-bottom: 1px solid #ddd; line-height: 2;/* 2倍于em */ font-size: 1.5em;&#125;.cal-weekend &#123; background-color: #fef0f0; background-color: rgba(255, 0, 0, 0.05);/* 应用一些透明度，这是一种兼容性写法 */&#125;.cal th,.cal td &#123; line-height: 3; padding: 0; width: 14.285%;&#125;.cal td &#123; border: 1px solid #eee;/* 给单元格加上边框，增加辨识度 */&#125;.cal thead &#123; border-bottom: 3px solid #666;&#125;.cal a &#123; display: block;/* 调整为块元素，它就会撑满整个单元格，增加点击区域 */ text-decoration: none; color: #2f273c;&#125;.cal a:hover,.cal a:focus &#123; background-color: #cde7ca;/* 这里有3种染色，分别针对非本月，当前日，备选日，加上之前的周末一共4种染色 */ background-color: rgba(167, 240, 210, 0.3);&#125;.cal-inactive &#123; background-color: #efefef; color: #aaa; cursor: not-allowed;&#125;.cal-current &#123; background-color: #7d5977; background-color: rgba(71, 14, 62, 0.6); color: #fff;&#125;.cal-current a &#123; color: #fff;&#125; 效果截图： 文章参考 精通CSS：高级Web标准解决方案（第3版）","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"CSS小积木","slug":"前端/CSS/CSS小积木","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/CSS/CSS%E5%B0%8F%E7%A7%AF%E6%9C%A8/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"CSS小积木-什么是小积木","slug":"css-building-blocks/cbb-what-is-this","date":"2020-03-17T16:45:08.000Z","updated":"2021-07-22T01:19:58.369Z","comments":true,"path":"2020/03/18/css-building-blocks/cbb-what-is-this/","link":"","permalink":"http://yoursite.com/2020/03/18/css-building-blocks/cbb-what-is-this/","excerpt":"CSS小积木是个什么东西 概述 这个叫做CSS小积木的系列是我css-building-blocks的配套博文，主要是一些常用的，收集来的或者是自己写的CSS片段，收录起来，在构建前端样式时可以“拿来主义”，用以快速构建和反映。长期更新","text":"CSS小积木是个什么东西 概述 这个叫做CSS小积木的系列是我css-building-blocks的配套博文，主要是一些常用的，收集来的或者是自己写的CSS片段，收录起来，在构建前端样式时可以“拿来主义”，用以快速构建和反映。长期更新 声明 本系列中的代码片段多是我实际编程过程中原创或者是学习大佬的代码时收录的，如果存在版权问题或者疑似抄袭，可以在评论区或者仓库的issue里bb我，如果你发现错误或者可以改进的地方也可以戳我，感谢支持","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"CSS小积木","slug":"前端/CSS/CSS小积木","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/CSS/CSS%E5%B0%8F%E7%A7%AF%E6%9C%A8/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"测试用例","slug":"test","date":"2020-03-14T17:26:43.000Z","updated":"2021-07-22T01:19:58.372Z","comments":true,"path":"2020/03/15/test/","link":"","permalink":"http://yoursite.com/2020/03/15/test/","excerpt":"测试用例","text":"测试用例 测试标题 233 测试图片 测试链接 维基百科 维基百科2","categories":[],"tags":[]}],"categories":[{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/categories/%E6%B1%87%E7%BC%96/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划专栏","slug":"算法/动态规划专栏","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E6%A0%8F/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论专栏","slug":"算法/数据结构/图论专栏","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E8%AE%BA%E4%B8%93%E6%A0%8F/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"经典算法","slug":"算法/经典算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"},{"name":"算法题解","slug":"算法/算法题解","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"},{"name":"字符串","slug":"算法/经典算法/字符串","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Spring","slug":"Java/Spring","permalink":"http://yoursite.com/categories/Java/Spring/"},{"name":"Spring-JDBC","slug":"Java/Spring/Spring-JDBC","permalink":"http://yoursite.com/categories/Java/Spring/Spring-JDBC/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"CSS小积木","slug":"前端/CSS/CSS小积木","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/CSS/CSS%E5%B0%8F%E7%A7%AF%E6%9C%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"踩坑日常","slug":"Linux/踩坑日常","permalink":"http://yoursite.com/categories/Linux/%E8%B8%A9%E5%9D%91%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"x86","slug":"x86","permalink":"http://yoursite.com/tags/x86/"},{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/tags/%E6%B1%87%E7%BC%96/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"排列组合","slug":"排列组合","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"},{"name":"回溯问题","slug":"回溯问题","permalink":"http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"习题","slug":"习题","permalink":"http://yoursite.com/tags/%E4%B9%A0%E9%A2%98/"},{"name":"递归","slug":"递归","permalink":"http://yoursite.com/tags/%E9%80%92%E5%BD%92/"},{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"},{"name":"jdbc","slug":"jdbc","permalink":"http://yoursite.com/tags/jdbc/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"manjaro kde plasma","slug":"manjaro-kde-plasma","permalink":"http://yoursite.com/tags/manjaro-kde-plasma/"}]}